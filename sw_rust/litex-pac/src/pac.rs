# ! [doc = "Peripheral access API for SOC microcontrollers (generated using svd2rust v0.33.5 (1d11c4a 2023-05-25))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.5/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
pub trait RawReg : Copy + Default + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > { # [doc = " Mask for bits of width `WI`"]
fn mask < const WI : u8 > () -> Self ; # [doc = " Mask for bits of width 1"]
fn one () -> Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U { # [inline (always)]
fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } # [inline (always)]
fn one () -> Self { 1 } } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } impl FieldSpec for $ U { type Ux = $ U ; } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : RawReg ; } # [doc = " Raw field type"]
pub trait FieldSpec : Sized { # [doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
type Ux : Copy + core :: fmt :: Debug + PartialEq + From < Self > ; } # [doc = " Marker for fields with fixed values"]
pub trait IsEnum : FieldSpec { } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also be `modify`'ed."]
pub trait Readable : RegisterSpec { } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also be `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Is it safe to write any bits to register"]
type Safety ; # [doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; # [doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
const RESET_VALUE : Self :: Ux ; # [doc = " Reset value of the register."]
# [inline (always)]
fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } } # [doc (hidden)]
pub mod raw { use super :: { marker , BitM , FieldSpec , RegisterSpec , Unsafe , Writable } ; pub struct R < REG : RegisterSpec > { pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct W < REG : RegisterSpec > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct FieldReader < FI = u8 > where FI : FieldSpec , { pub (crate) bits : FI :: Ux , _reg : marker :: PhantomData < FI > , } impl < FI : FieldSpec > FieldReader < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) const fn new (bits : FI :: Ux) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct BitReader < FI = bool > { pub (crate) bits : bool , _reg : marker :: PhantomData < FI > , } impl < FI > BitReader < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) const fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > where REG : Writable + RegisterSpec , FI : FieldSpec , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , Safety) > , } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } } pub struct BitWriter < 'a , REG , FI = bool , M = BitM > where REG : Writable + RegisterSpec , bool : From < FI > , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , REG , FI , M > BitWriter < 'a , REG , FI , M > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub type R < REG > = raw :: R < REG > ; impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub const fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub type W < REG > = raw :: W < REG > ; impl < REG : Writable > W < REG > { # [doc = " Writes raw bits to the register."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } impl < REG > W < REG > where REG : Writable < Safety = Safe > { # [doc = " Writes raw bits to the register."]
# [inline (always)]
pub fn set (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < FI = u8 > = raw :: FieldReader < FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI = bool > = raw :: BitReader < FI > ; impl < FI : FieldSpec > FieldReader < FI > { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub const fn bits (& self) -> FI :: Ux { self . bits } } impl < FI : FieldSpec > core :: fmt :: Debug for FieldReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } } impl < FI > PartialEq < FI > for FieldReader < FI > where FI : FieldSpec + Copy , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& FI :: Ux :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub const fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub const fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub const fn bit_is_set (& self) -> bool { self . bit () } } impl < FI > core :: fmt :: Debug for BitReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } } # [doc = " Marker for register/field writers which can take any value of specified width"]
pub struct Safe ; # [doc = " You should check that value is allowed to pass to register/field writer marked with this"]
pub struct Unsafe ; # [doc = " Marker for field writers are safe to write in specified inclusive range"]
pub struct Range < const MIN : u64 , const MAX : u64 > ; # [doc = " Marker for field writers are safe to write in specified inclusive range"]
pub struct RangeFrom < const MIN : u64 > ; # [doc = " Marker for field writers are safe to write in specified inclusive range"]
pub struct RangeTo < const MAX : u64 > ; # [doc = " Write field Proxy"]
pub type FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > = raw :: FieldWriter < 'a , REG , WI , FI , Safety > ; impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; # [doc = " Field width"]
# [inline (always)]
pub const fn width (& self) -> u8 { WI } # [doc = " Field offset"]
# [inline (always)]
pub const fn offset (& self) -> u8 { self . o } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << self . o ; self . w } } impl < 'a , REG , const WI : u8 , FI > FieldWriter < 'a , REG , WI , FI , Safe > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , Range < MIN , MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN && value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 > FieldWriter < 'a , REG , WI , FI , RangeFrom < MIN > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , RangeTo < MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : IsEnum , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut W < REG > { unsafe { self . bits (FI :: Ux :: from (variant)) } } } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , REG , FI = bool > = raw :: BitWriter <'a , REG , FI , $ mwv >; impl <'a , REG , FI > $ writer <'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; # [doc = " Field width"]
# [inline (always)]
pub const fn width (& self) -> u8 { Self :: WIDTH } # [doc = " Field offset"]
# [inline (always)]
pub const fn offset (& self) -> u8 { self . o } # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: one ()) << self . o ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut W < REG > { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , REG , FI > BitWriter < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> R < REG > { R { bits : self . register . get () , _reg : marker :: PhantomData , } } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { self . register . set (f (& mut W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) . bits ,) ; } } impl < REG : Writable > Reg < REG > { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { self . register . set (f (& mut W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , }) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> & 'w mut W < REG > , { let bits = self . register . get () ; self . register . set (f (& R { bits , _reg : marker :: PhantomData , } , & mut W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ,) . bits ,) ; } } impl < REG : Readable > core :: fmt :: Debug for crate :: generic :: Reg < REG > where R < REG > : core :: fmt :: Debug { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . read () , f) } } } # [cfg (feature = "rt")]
extern "C" { fn uart () ; fn timer0 () ; fn ethmac () ; } # [doc (hidden)]
# [repr (C)]
pub union Vector { pub _handler : unsafe extern "C" fn () , pub _reserved : usize , } # [cfg (feature = "rt")]
# [doc (hidden)]
# [no_mangle]
pub static __EXTERNAL_INTERRUPTS : [Vector ; 3]
= [Vector { _handler : uart } , Vector { _handler : timer0 } , Vector { _handler : ethmac } ,]
; # [doc (hidden)]
pub mod interrupt { # [doc = r"Enumeration of all the interrupts."]
# [derive (Copy , Clone , Debug , PartialEq , Eq)]
# [repr (u16)]
pub enum Interrupt { # [doc = "0 - uart"]
uart = 0 , # [doc = "1 - timer0"]
timer0 = 1 , # [doc = "2 - ethmac"]
ethmac = 2 , } # [doc = r" TryFromInterruptError"]
# [derive (Debug , Copy , Clone)]
pub struct TryFromInterruptError (()) ; impl Interrupt { # [doc = r" Attempt to convert a given value into an `Interrupt`"]
# [inline]
pub fn try_from (value : u8) -> Result < Self , TryFromInterruptError > { match value { 0 => Ok (Interrupt :: uart) , 1 => Ok (Interrupt :: timer0) , 2 => Ok (Interrupt :: ethmac) , _ => Err (TryFromInterruptError (())) , } } } # [cfg (feature = "rt")]
# [macro_export]
# [doc = r" Assigns a handler to an interrupt"]
# [doc = r""]
# [doc = r" This macro takes two arguments: the name of an interrupt and the path to the"]
# [doc = r" function that will be used as the handler of that interrupt. That function"]
# [doc = r" must have signature `fn()`."]
# [doc = r""]
# [doc = r" Optionally, a third argument may be used to declare interrupt local data."]
# [doc = r" The handler will have exclusive access to these *local* variables on each"]
# [doc = r" invocation. If the third argument is used then the signature of the handler"]
# [doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument"]
# [doc = r" passed to the macro."]
# [doc = r""]
# [doc = r" # Example"]
# [doc = r""]
# [doc = r" ``` ignore"]
# [doc = r" interrupt!(TIM2, periodic);"]
# [doc = r""]
# [doc = r" fn periodic() {"]
# [doc = r#"     print!(".");"#]
# [doc = r" }"]
# [doc = r""]
# [doc = r" interrupt!(TIM3, tick, locals: {"]
# [doc = r"     tick: bool = false;"]
# [doc = r" });"]
# [doc = r""]
# [doc = r" fn tick(locals: &mut TIM3::Locals) {"]
# [doc = r"     locals.tick = !locals.tick;"]
# [doc = r""]
# [doc = r"     if locals.tick {"]
# [doc = r#"         println!("Tick");"#]
# [doc = r"     } else {"]
# [doc = r#"         println!("Tock");"#]
# [doc = r"     }"]
# [doc = r" }"]
# [doc = r" ```"]
macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } } } pub use self :: interrupt :: Interrupt ; # [doc = "SPIFLASH_MMAP"]
pub struct SpiflashMmap { _marker : PhantomData < * const () > } unsafe impl Send for SpiflashMmap { } impl SpiflashMmap { # [doc = r"Pointer to the register block"]
pub const PTR : * const spiflash_mmap :: RegisterBlock = 0xf000_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spiflash_mmap :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for SpiflashMmap { type Target = spiflash_mmap :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SpiflashMmap { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SpiflashMmap") . finish () } } # [doc = "SPIFLASH_MMAP"]
pub mod spiflash_mmap { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { mmap_dummy_bits : MmapDummyBits , master_cs : MasterCs , master_phyconfig : MasterPhyconfig , master_rxtx : MasterRxtx , master_status : MasterStatus , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn mmap_dummy_bits (& self) -> & MmapDummyBits { & self . mmap_dummy_bits } # [doc = "0x04 - "]
# [inline (always)]
pub const fn master_cs (& self) -> & MasterCs { & self . master_cs } # [doc = "0x08 - SPI PHY settings."]
# [inline (always)]
pub const fn master_phyconfig (& self) -> & MasterPhyconfig { & self . master_phyconfig } # [doc = "0x0c - "]
# [inline (always)]
pub const fn master_rxtx (& self) -> & MasterRxtx { & self . master_rxtx } # [doc = "0x10 - "]
# [inline (always)]
pub const fn master_status (& self) -> & MasterStatus { & self . master_status } } # [doc = "MMAP_DUMMY_BITS (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`mmap_dummy_bits::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmap_dummy_bits::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmap_dummy_bits`]
module"]
# [doc (alias = "MMAP_DUMMY_BITS")]
pub type MmapDummyBits = crate :: Reg < mmap_dummy_bits :: MmapDummyBitsSpec > ; # [doc = ""]
pub mod mmap_dummy_bits { # [doc = "Register `MMAP_DUMMY_BITS` reader"]
pub type R = crate :: R < MmapDummyBitsSpec > ; # [doc = "Register `MMAP_DUMMY_BITS` writer"]
pub type W = crate :: W < MmapDummyBitsSpec > ; # [doc = "Field `mmap_dummy_bits` reader - "]
pub type MmapDummyBitsR = crate :: FieldReader ; # [doc = "Field `mmap_dummy_bits` writer - "]
pub type MmapDummyBitsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn mmap_dummy_bits (& self) -> MmapDummyBitsR { MmapDummyBitsR :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7"]
# [inline (always)]
# [must_use]
pub fn mmap_dummy_bits (& mut self) -> MmapDummyBitsW < MmapDummyBitsSpec > { MmapDummyBitsW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`mmap_dummy_bits::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmap_dummy_bits::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MmapDummyBitsSpec ; impl crate :: RegisterSpec for MmapDummyBitsSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mmap_dummy_bits::R`](R) reader structure"]
impl crate :: Readable for MmapDummyBitsSpec { } # [doc = "`write(|w| ..)` method takes [`mmap_dummy_bits::W`](W) writer structure"]
impl crate :: Writable for MmapDummyBitsSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MMAP_DUMMY_BITS to value 0"]
impl crate :: Resettable for MmapDummyBitsSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MASTER_CS (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`master_cs::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`master_cs::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@master_cs`]
module"]
# [doc (alias = "MASTER_CS")]
pub type MasterCs = crate :: Reg < master_cs :: MasterCsSpec > ; # [doc = ""]
pub mod master_cs { # [doc = "Register `MASTER_CS` reader"]
pub type R = crate :: R < MasterCsSpec > ; # [doc = "Register `MASTER_CS` writer"]
pub type W = crate :: W < MasterCsSpec > ; # [doc = "Field `master_cs` reader - "]
pub type MasterCsR = crate :: BitReader ; # [doc = "Field `master_cs` writer - "]
pub type MasterCsW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn master_cs (& self) -> MasterCsR { MasterCsR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn master_cs (& mut self) -> MasterCsW < MasterCsSpec > { MasterCsW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`master_cs::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`master_cs::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MasterCsSpec ; impl crate :: RegisterSpec for MasterCsSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`master_cs::R`](R) reader structure"]
impl crate :: Readable for MasterCsSpec { } # [doc = "`write(|w| ..)` method takes [`master_cs::W`](W) writer structure"]
impl crate :: Writable for MasterCsSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MASTER_CS to value 0"]
impl crate :: Resettable for MasterCsSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MASTER_PHYCONFIG (rw) register accessor: SPI PHY settings.\n\nYou can [`read`](crate::Reg::read) this register and get [`master_phyconfig::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`master_phyconfig::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@master_phyconfig`]
module"]
# [doc (alias = "MASTER_PHYCONFIG")]
pub type MasterPhyconfig = crate :: Reg < master_phyconfig :: MasterPhyconfigSpec > ; # [doc = "SPI PHY settings."]
pub mod master_phyconfig { # [doc = "Register `MASTER_PHYCONFIG` reader"]
pub type R = crate :: R < MasterPhyconfigSpec > ; # [doc = "Register `MASTER_PHYCONFIG` writer"]
pub type W = crate :: W < MasterPhyconfigSpec > ; # [doc = "Field `len` reader - SPI Xfer length (in bits)."]
pub type LenR = crate :: FieldReader ; # [doc = "Field `len` writer - SPI Xfer length (in bits)."]
pub type LenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `width` reader - SPI Xfer width (1/2/4/8)."]
pub type WidthR = crate :: FieldReader ; # [doc = "Field `width` writer - SPI Xfer width (1/2/4/8)."]
pub type WidthW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `mask` reader - SPI DQ output enable mask (set bits to ``1`` to enable output drivers on DQ lines)."]
pub type MaskR = crate :: FieldReader ; # [doc = "Field `mask` writer - SPI DQ output enable mask (set bits to ``1`` to enable output drivers on DQ lines)."]
pub type MaskW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7 - SPI Xfer length (in bits)."]
# [inline (always)]
pub fn len (& self) -> LenR { LenR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:11 - SPI Xfer width (1/2/4/8)."]
# [inline (always)]
pub fn width (& self) -> WidthR { WidthR :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bits 16:23 - SPI DQ output enable mask (set bits to ``1`` to enable output drivers on DQ lines)."]
# [inline (always)]
pub fn mask (& self) -> MaskR { MaskR :: new (((self . bits >> 16) & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - SPI Xfer length (in bits)."]
# [inline (always)]
# [must_use]
pub fn len (& mut self) -> LenW < MasterPhyconfigSpec > { LenW :: new (self , 0) } # [doc = "Bits 8:11 - SPI Xfer width (1/2/4/8)."]
# [inline (always)]
# [must_use]
pub fn width (& mut self) -> WidthW < MasterPhyconfigSpec > { WidthW :: new (self , 8) } # [doc = "Bits 16:23 - SPI DQ output enable mask (set bits to ``1`` to enable output drivers on DQ lines)."]
# [inline (always)]
# [must_use]
pub fn mask (& mut self) -> MaskW < MasterPhyconfigSpec > { MaskW :: new (self , 16) } } # [doc = "SPI PHY settings.\n\nYou can [`read`](crate::Reg::read) this register and get [`master_phyconfig::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`master_phyconfig::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MasterPhyconfigSpec ; impl crate :: RegisterSpec for MasterPhyconfigSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`master_phyconfig::R`](R) reader structure"]
impl crate :: Readable for MasterPhyconfigSpec { } # [doc = "`write(|w| ..)` method takes [`master_phyconfig::W`](W) writer structure"]
impl crate :: Writable for MasterPhyconfigSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MASTER_PHYCONFIG to value 0"]
impl crate :: Resettable for MasterPhyconfigSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MASTER_RXTX (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`master_rxtx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`master_rxtx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@master_rxtx`]
module"]
# [doc (alias = "MASTER_RXTX")]
pub type MasterRxtx = crate :: Reg < master_rxtx :: MasterRxtxSpec > ; # [doc = ""]
pub mod master_rxtx { # [doc = "Register `MASTER_RXTX` reader"]
pub type R = crate :: R < MasterRxtxSpec > ; # [doc = "Register `MASTER_RXTX` writer"]
pub type W = crate :: W < MasterRxtxSpec > ; # [doc = "Field `master_rxtx` reader - "]
pub type MasterRxtxR = crate :: FieldReader < u32 > ; # [doc = "Field `master_rxtx` writer - "]
pub type MasterRxtxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn master_rxtx (& self) -> MasterRxtxR { MasterRxtxR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn master_rxtx (& mut self) -> MasterRxtxW < MasterRxtxSpec > { MasterRxtxW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`master_rxtx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`master_rxtx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MasterRxtxSpec ; impl crate :: RegisterSpec for MasterRxtxSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`master_rxtx::R`](R) reader structure"]
impl crate :: Readable for MasterRxtxSpec { } # [doc = "`write(|w| ..)` method takes [`master_rxtx::W`](W) writer structure"]
impl crate :: Writable for MasterRxtxSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MASTER_RXTX to value 0"]
impl crate :: Resettable for MasterRxtxSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MASTER_STATUS (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`master_status::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`master_status::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@master_status`]
module"]
# [doc (alias = "MASTER_STATUS")]
pub type MasterStatus = crate :: Reg < master_status :: MasterStatusSpec > ; # [doc = ""]
pub mod master_status { # [doc = "Register `MASTER_STATUS` reader"]
pub type R = crate :: R < MasterStatusSpec > ; # [doc = "Register `MASTER_STATUS` writer"]
pub type W = crate :: W < MasterStatusSpec > ; # [doc = "Field `tx_ready` reader - TX FIFO is not full."]
pub type TxReadyR = crate :: BitReader ; # [doc = "Field `tx_ready` writer - TX FIFO is not full."]
pub type TxReadyW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `rx_ready` reader - RX FIFO is not empty."]
pub type RxReadyR = crate :: BitReader ; # [doc = "Field `rx_ready` writer - RX FIFO is not empty."]
pub type RxReadyW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - TX FIFO is not full."]
# [inline (always)]
pub fn tx_ready (& self) -> TxReadyR { TxReadyR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - RX FIFO is not empty."]
# [inline (always)]
pub fn rx_ready (& self) -> RxReadyR { RxReadyR :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - TX FIFO is not full."]
# [inline (always)]
# [must_use]
pub fn tx_ready (& mut self) -> TxReadyW < MasterStatusSpec > { TxReadyW :: new (self , 0) } # [doc = "Bit 1 - RX FIFO is not empty."]
# [inline (always)]
# [must_use]
pub fn rx_ready (& mut self) -> RxReadyW < MasterStatusSpec > { RxReadyW :: new (self , 1) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`master_status::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`master_status::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MasterStatusSpec ; impl crate :: RegisterSpec for MasterStatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`master_status::R`](R) reader structure"]
impl crate :: Readable for MasterStatusSpec { } # [doc = "`write(|w| ..)` method takes [`master_status::W`](W) writer structure"]
impl crate :: Writable for MasterStatusSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MASTER_STATUS to value 0"]
impl crate :: Resettable for MasterStatusSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "SPIFLASH_PHY"]
pub struct SpiflashPhy { _marker : PhantomData < * const () > } unsafe impl Send for SpiflashPhy { } impl SpiflashPhy { # [doc = r"Pointer to the register block"]
pub const PTR : * const spiflash_phy :: RegisterBlock = 0xf000_0800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spiflash_phy :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for SpiflashPhy { type Target = spiflash_phy :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SpiflashPhy { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SpiflashPhy") . finish () } } # [doc = "SPIFLASH_PHY"]
pub mod spiflash_phy { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { clk_divisor : ClkDivisor , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn clk_divisor (& self) -> & ClkDivisor { & self . clk_divisor } } # [doc = "CLK_DIVISOR (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`clk_divisor::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_divisor::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_divisor`]
module"]
# [doc (alias = "CLK_DIVISOR")]
pub type ClkDivisor = crate :: Reg < clk_divisor :: ClkDivisorSpec > ; # [doc = ""]
pub mod clk_divisor { # [doc = "Register `CLK_DIVISOR` reader"]
pub type R = crate :: R < ClkDivisorSpec > ; # [doc = "Register `CLK_DIVISOR` writer"]
pub type W = crate :: W < ClkDivisorSpec > ; # [doc = "Field `clk_divisor` reader - "]
pub type ClkDivisorR = crate :: FieldReader ; # [doc = "Field `clk_divisor` writer - "]
pub type ClkDivisorW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn clk_divisor (& self) -> ClkDivisorR { ClkDivisorR :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7"]
# [inline (always)]
# [must_use]
pub fn clk_divisor (& mut self) -> ClkDivisorW < ClkDivisorSpec > { ClkDivisorW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_divisor::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_divisor::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClkDivisorSpec ; impl crate :: RegisterSpec for ClkDivisorSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`clk_divisor::R`](R) reader structure"]
impl crate :: Readable for ClkDivisorSpec { } # [doc = "`write(|w| ..)` method takes [`clk_divisor::W`](W) writer structure"]
impl crate :: Writable for ClkDivisorSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLK_DIVISOR to value 0x09"]
impl crate :: Resettable for ClkDivisorSpec { const RESET_VALUE : u32 = 0x09 ; } } } # [doc = "CTRL"]
pub struct Ctrl { _marker : PhantomData < * const () > } unsafe impl Send for Ctrl { } impl Ctrl { # [doc = r"Pointer to the register block"]
pub const PTR : * const ctrl :: RegisterBlock = 0xf000_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ctrl :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Ctrl { type Target = ctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Ctrl { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ctrl") . finish () } } # [doc = "CTRL"]
pub mod ctrl { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { reset : Reset , scratch : Scratch , bus_errors : BusErrors , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn reset (& self) -> & Reset { & self . reset } # [doc = "0x04 - Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness."]
# [inline (always)]
pub const fn scratch (& self) -> & Scratch { & self . scratch } # [doc = "0x08 - Total number of Wishbone bus errors (timeouts) since start."]
# [inline (always)]
pub const fn bus_errors (& self) -> & BusErrors { & self . bus_errors } } # [doc = "RESET (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`reset::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reset::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reset`]
module"]
# [doc (alias = "RESET")]
pub type Reset = crate :: Reg < reset :: ResetSpec > ; # [doc = ""]
pub mod reset { # [doc = "Register `RESET` reader"]
pub type R = crate :: R < ResetSpec > ; # [doc = "Register `RESET` writer"]
pub type W = crate :: W < ResetSpec > ; # [doc = "Field `soc_rst` reader - Write `1` to this register to reset the full SoC (Pulse Reset)"]
pub type SocRstR = crate :: BitReader ; # [doc = "Field `soc_rst` writer - Write `1` to this register to reset the full SoC (Pulse Reset)"]
pub type SocRstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `cpu_rst` reader - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
pub type CpuRstR = crate :: BitReader ; # [doc = "Field `cpu_rst` writer - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
pub type CpuRstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Write `1` to this register to reset the full SoC (Pulse Reset)"]
# [inline (always)]
pub fn soc_rst (& self) -> SocRstR { SocRstR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
# [inline (always)]
pub fn cpu_rst (& self) -> CpuRstR { CpuRstR :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Write `1` to this register to reset the full SoC (Pulse Reset)"]
# [inline (always)]
# [must_use]
pub fn soc_rst (& mut self) -> SocRstW < ResetSpec > { SocRstW :: new (self , 0) } # [doc = "Bit 1 - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
# [inline (always)]
# [must_use]
pub fn cpu_rst (& mut self) -> CpuRstW < ResetSpec > { CpuRstW :: new (self , 1) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`reset::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reset::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ResetSpec ; impl crate :: RegisterSpec for ResetSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`reset::R`](R) reader structure"]
impl crate :: Readable for ResetSpec { } # [doc = "`write(|w| ..)` method takes [`reset::W`](W) writer structure"]
impl crate :: Writable for ResetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RESET to value 0"]
impl crate :: Resettable for ResetSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SCRATCH (rw) register accessor: Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness.\n\nYou can [`read`](crate::Reg::read) this register and get [`scratch::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`scratch::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@scratch`]
module"]
# [doc (alias = "SCRATCH")]
pub type Scratch = crate :: Reg < scratch :: ScratchSpec > ; # [doc = "Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness."]
pub mod scratch { # [doc = "Register `SCRATCH` reader"]
pub type R = crate :: R < ScratchSpec > ; # [doc = "Register `SCRATCH` writer"]
pub type W = crate :: W < ScratchSpec > ; # [doc = "Field `scratch` reader - "]
pub type ScratchR = crate :: FieldReader < u32 > ; # [doc = "Field `scratch` writer - "]
pub type ScratchW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn scratch (& self) -> ScratchR { ScratchR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn scratch (& mut self) -> ScratchW < ScratchSpec > { ScratchW :: new (self , 0) } } # [doc = "Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness.\n\nYou can [`read`](crate::Reg::read) this register and get [`scratch::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`scratch::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ScratchSpec ; impl crate :: RegisterSpec for ScratchSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`scratch::R`](R) reader structure"]
impl crate :: Readable for ScratchSpec { } # [doc = "`write(|w| ..)` method takes [`scratch::W`](W) writer structure"]
impl crate :: Writable for ScratchSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SCRATCH to value 0x1234_5678"]
impl crate :: Resettable for ScratchSpec { const RESET_VALUE : u32 = 0x1234_5678 ; } } # [doc = "BUS_ERRORS (rw) register accessor: Total number of Wishbone bus errors (timeouts) since start.\n\nYou can [`read`](crate::Reg::read) this register and get [`bus_errors::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bus_errors::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bus_errors`]
module"]
# [doc (alias = "BUS_ERRORS")]
pub type BusErrors = crate :: Reg < bus_errors :: BusErrorsSpec > ; # [doc = "Total number of Wishbone bus errors (timeouts) since start."]
pub mod bus_errors { # [doc = "Register `BUS_ERRORS` reader"]
pub type R = crate :: R < BusErrorsSpec > ; # [doc = "Register `BUS_ERRORS` writer"]
pub type W = crate :: W < BusErrorsSpec > ; # [doc = "Field `bus_errors` reader - "]
pub type BusErrorsR = crate :: FieldReader < u32 > ; # [doc = "Field `bus_errors` writer - "]
pub type BusErrorsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn bus_errors (& self) -> BusErrorsR { BusErrorsR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn bus_errors (& mut self) -> BusErrorsW < BusErrorsSpec > { BusErrorsW :: new (self , 0) } } # [doc = "Total number of Wishbone bus errors (timeouts) since start.\n\nYou can [`read`](crate::Reg::read) this register and get [`bus_errors::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bus_errors::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BusErrorsSpec ; impl crate :: RegisterSpec for BusErrorsSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`bus_errors::R`](R) reader structure"]
impl crate :: Readable for BusErrorsSpec { } # [doc = "`write(|w| ..)` method takes [`bus_errors::W`](W) writer structure"]
impl crate :: Writable for BusErrorsSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets BUS_ERRORS to value 0"]
impl crate :: Resettable for BusErrorsSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "ETHMAC"]
pub struct Ethmac { _marker : PhantomData < * const () > } unsafe impl Send for Ethmac { } impl Ethmac { # [doc = r"Pointer to the register block"]
pub const PTR : * const ethmac :: RegisterBlock = 0xf000_1800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ethmac :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Ethmac { type Target = ethmac :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Ethmac { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ethmac") . finish () } } # [doc = "ETHMAC"]
pub mod ethmac { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { sram_writer_slot : SramWriterSlot , sram_writer_length : SramWriterLength , sram_writer_errors : SramWriterErrors , sram_writer_ev_status : SramWriterEvStatus , sram_writer_ev_pending : SramWriterEvPending , sram_writer_ev_enable : SramWriterEvEnable , sram_reader_start : SramReaderStart , sram_reader_ready : SramReaderReady , sram_reader_level : SramReaderLevel , sram_reader_slot : SramReaderSlot , sram_reader_length : SramReaderLength , sram_reader_ev_status : SramReaderEvStatus , sram_reader_ev_pending : SramReaderEvPending , sram_reader_ev_enable : SramReaderEvEnable , preamble_crc : PreambleCrc , rx_datapath_preamble_errors : RxDatapathPreambleErrors , rx_datapath_crc_errors : RxDatapathCrcErrors , ip_address : IpAddress , mac_address1 : MacAddress1 , mac_address0 : MacAddress0 , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn sram_writer_slot (& self) -> & SramWriterSlot { & self . sram_writer_slot } # [doc = "0x04 - "]
# [inline (always)]
pub const fn sram_writer_length (& self) -> & SramWriterLength { & self . sram_writer_length } # [doc = "0x08 - "]
# [inline (always)]
pub const fn sram_writer_errors (& self) -> & SramWriterErrors { & self . sram_writer_errors } # [doc = "0x0c - This register contains the current raw level of the available event trigger. Writes to this register have no effect."]
# [inline (always)]
pub const fn sram_writer_ev_status (& self) -> & SramWriterEvStatus { & self . sram_writer_ev_status } # [doc = "0x10 - When a available event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
# [inline (always)]
pub const fn sram_writer_ev_pending (& self) -> & SramWriterEvPending { & self . sram_writer_ev_pending } # [doc = "0x14 - This register enables the corresponding available events. Write a ``0`` to this register to disable individual events."]
# [inline (always)]
pub const fn sram_writer_ev_enable (& self) -> & SramWriterEvEnable { & self . sram_writer_ev_enable } # [doc = "0x18 - "]
# [inline (always)]
pub const fn sram_reader_start (& self) -> & SramReaderStart { & self . sram_reader_start } # [doc = "0x1c - "]
# [inline (always)]
pub const fn sram_reader_ready (& self) -> & SramReaderReady { & self . sram_reader_ready } # [doc = "0x20 - "]
# [inline (always)]
pub const fn sram_reader_level (& self) -> & SramReaderLevel { & self . sram_reader_level } # [doc = "0x24 - "]
# [inline (always)]
pub const fn sram_reader_slot (& self) -> & SramReaderSlot { & self . sram_reader_slot } # [doc = "0x28 - "]
# [inline (always)]
pub const fn sram_reader_length (& self) -> & SramReaderLength { & self . sram_reader_length } # [doc = "0x2c - This register contains the current raw level of the event0 event trigger. Writes to this register have no effect."]
# [inline (always)]
pub const fn sram_reader_ev_status (& self) -> & SramReaderEvStatus { & self . sram_reader_ev_status } # [doc = "0x30 - When a event0 event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
# [inline (always)]
pub const fn sram_reader_ev_pending (& self) -> & SramReaderEvPending { & self . sram_reader_ev_pending } # [doc = "0x34 - This register enables the corresponding event0 events. Write a ``0`` to this register to disable individual events."]
# [inline (always)]
pub const fn sram_reader_ev_enable (& self) -> & SramReaderEvEnable { & self . sram_reader_ev_enable } # [doc = "0x38 - "]
# [inline (always)]
pub const fn preamble_crc (& self) -> & PreambleCrc { & self . preamble_crc } # [doc = "0x3c - "]
# [inline (always)]
pub const fn rx_datapath_preamble_errors (& self) -> & RxDatapathPreambleErrors { & self . rx_datapath_preamble_errors } # [doc = "0x40 - "]
# [inline (always)]
pub const fn rx_datapath_crc_errors (& self) -> & RxDatapathCrcErrors { & self . rx_datapath_crc_errors } # [doc = "0x44 - "]
# [inline (always)]
pub const fn ip_address (& self) -> & IpAddress { & self . ip_address } # [doc = "0x48 - Bits 32-47 of `ETHMAC_MAC_ADDRESS`. The value won't take effect until `ETHMAC_MAC_ADDRESS0` is written."]
# [inline (always)]
pub const fn mac_address1 (& self) -> & MacAddress1 { & self . mac_address1 } # [doc = "0x4c - Bits 0-31 of `ETHMAC_MAC_ADDRESS`. Writing this register triggers an update of `ETHMAC_MAC_ADDRESS`."]
# [inline (always)]
pub const fn mac_address0 (& self) -> & MacAddress0 { & self . mac_address0 } } # [doc = "SRAM_WRITER_SLOT (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_slot::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_slot::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_writer_slot`]
module"]
# [doc (alias = "SRAM_WRITER_SLOT")]
pub type SramWriterSlot = crate :: Reg < sram_writer_slot :: SramWriterSlotSpec > ; # [doc = ""]
pub mod sram_writer_slot { # [doc = "Register `SRAM_WRITER_SLOT` reader"]
pub type R = crate :: R < SramWriterSlotSpec > ; # [doc = "Register `SRAM_WRITER_SLOT` writer"]
pub type W = crate :: W < SramWriterSlotSpec > ; # [doc = "Field `sram_writer_slot` reader - "]
pub type SramWriterSlotR = crate :: BitReader ; # [doc = "Field `sram_writer_slot` writer - "]
pub type SramWriterSlotW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn sram_writer_slot (& self) -> SramWriterSlotR { SramWriterSlotR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn sram_writer_slot (& mut self) -> SramWriterSlotW < SramWriterSlotSpec > { SramWriterSlotW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_slot::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_slot::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramWriterSlotSpec ; impl crate :: RegisterSpec for SramWriterSlotSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_writer_slot::R`](R) reader structure"]
impl crate :: Readable for SramWriterSlotSpec { } # [doc = "`write(|w| ..)` method takes [`sram_writer_slot::W`](W) writer structure"]
impl crate :: Writable for SramWriterSlotSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_WRITER_SLOT to value 0"]
impl crate :: Resettable for SramWriterSlotSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_WRITER_LENGTH (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_length::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_length::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_writer_length`]
module"]
# [doc (alias = "SRAM_WRITER_LENGTH")]
pub type SramWriterLength = crate :: Reg < sram_writer_length :: SramWriterLengthSpec > ; # [doc = ""]
pub mod sram_writer_length { # [doc = "Register `SRAM_WRITER_LENGTH` reader"]
pub type R = crate :: R < SramWriterLengthSpec > ; # [doc = "Register `SRAM_WRITER_LENGTH` writer"]
pub type W = crate :: W < SramWriterLengthSpec > ; # [doc = "Field `sram_writer_length` reader - "]
pub type SramWriterLengthR = crate :: FieldReader < u16 > ; # [doc = "Field `sram_writer_length` writer - "]
pub type SramWriterLengthW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ; impl R { # [doc = "Bits 0:10"]
# [inline (always)]
pub fn sram_writer_length (& self) -> SramWriterLengthR { SramWriterLengthR :: new ((self . bits & 0x07ff) as u16) } } impl W { # [doc = "Bits 0:10"]
# [inline (always)]
# [must_use]
pub fn sram_writer_length (& mut self) -> SramWriterLengthW < SramWriterLengthSpec > { SramWriterLengthW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_length::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_length::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramWriterLengthSpec ; impl crate :: RegisterSpec for SramWriterLengthSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_writer_length::R`](R) reader structure"]
impl crate :: Readable for SramWriterLengthSpec { } # [doc = "`write(|w| ..)` method takes [`sram_writer_length::W`](W) writer structure"]
impl crate :: Writable for SramWriterLengthSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_WRITER_LENGTH to value 0"]
impl crate :: Resettable for SramWriterLengthSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_WRITER_ERRORS (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_errors::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_errors::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_writer_errors`]
module"]
# [doc (alias = "SRAM_WRITER_ERRORS")]
pub type SramWriterErrors = crate :: Reg < sram_writer_errors :: SramWriterErrorsSpec > ; # [doc = ""]
pub mod sram_writer_errors { # [doc = "Register `SRAM_WRITER_ERRORS` reader"]
pub type R = crate :: R < SramWriterErrorsSpec > ; # [doc = "Register `SRAM_WRITER_ERRORS` writer"]
pub type W = crate :: W < SramWriterErrorsSpec > ; # [doc = "Field `sram_writer_errors` reader - "]
pub type SramWriterErrorsR = crate :: FieldReader < u32 > ; # [doc = "Field `sram_writer_errors` writer - "]
pub type SramWriterErrorsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn sram_writer_errors (& self) -> SramWriterErrorsR { SramWriterErrorsR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn sram_writer_errors (& mut self) -> SramWriterErrorsW < SramWriterErrorsSpec > { SramWriterErrorsW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_errors::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_errors::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramWriterErrorsSpec ; impl crate :: RegisterSpec for SramWriterErrorsSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_writer_errors::R`](R) reader structure"]
impl crate :: Readable for SramWriterErrorsSpec { } # [doc = "`write(|w| ..)` method takes [`sram_writer_errors::W`](W) writer structure"]
impl crate :: Writable for SramWriterErrorsSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_WRITER_ERRORS to value 0"]
impl crate :: Resettable for SramWriterErrorsSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_WRITER_EV_STATUS (rw) register accessor: This register contains the current raw level of the available event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_ev_status::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_ev_status::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_writer_ev_status`]
module"]
# [doc (alias = "SRAM_WRITER_EV_STATUS")]
pub type SramWriterEvStatus = crate :: Reg < sram_writer_ev_status :: SramWriterEvStatusSpec > ; # [doc = "This register contains the current raw level of the available event trigger. Writes to this register have no effect."]
pub mod sram_writer_ev_status { # [doc = "Register `SRAM_WRITER_EV_STATUS` reader"]
pub type R = crate :: R < SramWriterEvStatusSpec > ; # [doc = "Register `SRAM_WRITER_EV_STATUS` writer"]
pub type W = crate :: W < SramWriterEvStatusSpec > ; # [doc = "Field `available` reader - Level of the ``available`` event"]
pub type AvailableR = crate :: BitReader ; # [doc = "Field `available` writer - Level of the ``available`` event"]
pub type AvailableW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Level of the ``available`` event"]
# [inline (always)]
pub fn available (& self) -> AvailableR { AvailableR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Level of the ``available`` event"]
# [inline (always)]
# [must_use]
pub fn available (& mut self) -> AvailableW < SramWriterEvStatusSpec > { AvailableW :: new (self , 0) } } # [doc = "This register contains the current raw level of the available event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_ev_status::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_ev_status::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramWriterEvStatusSpec ; impl crate :: RegisterSpec for SramWriterEvStatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_writer_ev_status::R`](R) reader structure"]
impl crate :: Readable for SramWriterEvStatusSpec { } # [doc = "`write(|w| ..)` method takes [`sram_writer_ev_status::W`](W) writer structure"]
impl crate :: Writable for SramWriterEvStatusSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_WRITER_EV_STATUS to value 0"]
impl crate :: Resettable for SramWriterEvStatusSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_WRITER_EV_PENDING (rw) register accessor: When a available event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_ev_pending::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_ev_pending::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_writer_ev_pending`]
module"]
# [doc (alias = "SRAM_WRITER_EV_PENDING")]
pub type SramWriterEvPending = crate :: Reg < sram_writer_ev_pending :: SramWriterEvPendingSpec > ; # [doc = "When a available event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub mod sram_writer_ev_pending { # [doc = "Register `SRAM_WRITER_EV_PENDING` reader"]
pub type R = crate :: R < SramWriterEvPendingSpec > ; # [doc = "Register `SRAM_WRITER_EV_PENDING` writer"]
pub type W = crate :: W < SramWriterEvPendingSpec > ; # [doc = "Field `available` reader - `1` if a `available` event occurred. This Event is **level triggered** when the signal is **high**."]
pub type AvailableR = crate :: BitReader ; # [doc = "Field `available` writer - `1` if a `available` event occurred. This Event is **level triggered** when the signal is **high**."]
pub type AvailableW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - `1` if a `available` event occurred. This Event is **level triggered** when the signal is **high**."]
# [inline (always)]
pub fn available (& self) -> AvailableR { AvailableR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - `1` if a `available` event occurred. This Event is **level triggered** when the signal is **high**."]
# [inline (always)]
# [must_use]
pub fn available (& mut self) -> AvailableW < SramWriterEvPendingSpec > { AvailableW :: new (self , 0) } } # [doc = "When a available event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_ev_pending::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_ev_pending::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramWriterEvPendingSpec ; impl crate :: RegisterSpec for SramWriterEvPendingSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_writer_ev_pending::R`](R) reader structure"]
impl crate :: Readable for SramWriterEvPendingSpec { } # [doc = "`write(|w| ..)` method takes [`sram_writer_ev_pending::W`](W) writer structure"]
impl crate :: Writable for SramWriterEvPendingSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_WRITER_EV_PENDING to value 0"]
impl crate :: Resettable for SramWriterEvPendingSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_WRITER_EV_ENABLE (rw) register accessor: This register enables the corresponding available events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_ev_enable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_ev_enable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_writer_ev_enable`]
module"]
# [doc (alias = "SRAM_WRITER_EV_ENABLE")]
pub type SramWriterEvEnable = crate :: Reg < sram_writer_ev_enable :: SramWriterEvEnableSpec > ; # [doc = "This register enables the corresponding available events. Write a ``0`` to this register to disable individual events."]
pub mod sram_writer_ev_enable { # [doc = "Register `SRAM_WRITER_EV_ENABLE` reader"]
pub type R = crate :: R < SramWriterEvEnableSpec > ; # [doc = "Register `SRAM_WRITER_EV_ENABLE` writer"]
pub type W = crate :: W < SramWriterEvEnableSpec > ; # [doc = "Field `available` reader - Write a ``1`` to enable the ``available`` Event"]
pub type AvailableR = crate :: BitReader ; # [doc = "Field `available` writer - Write a ``1`` to enable the ``available`` Event"]
pub type AvailableW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Write a ``1`` to enable the ``available`` Event"]
# [inline (always)]
pub fn available (& self) -> AvailableR { AvailableR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Write a ``1`` to enable the ``available`` Event"]
# [inline (always)]
# [must_use]
pub fn available (& mut self) -> AvailableW < SramWriterEvEnableSpec > { AvailableW :: new (self , 0) } } # [doc = "This register enables the corresponding available events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_writer_ev_enable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_writer_ev_enable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramWriterEvEnableSpec ; impl crate :: RegisterSpec for SramWriterEvEnableSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_writer_ev_enable::R`](R) reader structure"]
impl crate :: Readable for SramWriterEvEnableSpec { } # [doc = "`write(|w| ..)` method takes [`sram_writer_ev_enable::W`](W) writer structure"]
impl crate :: Writable for SramWriterEvEnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_WRITER_EV_ENABLE to value 0"]
impl crate :: Resettable for SramWriterEvEnableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_READER_START (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_start::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_start::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_reader_start`]
module"]
# [doc (alias = "SRAM_READER_START")]
pub type SramReaderStart = crate :: Reg < sram_reader_start :: SramReaderStartSpec > ; # [doc = ""]
pub mod sram_reader_start { # [doc = "Register `SRAM_READER_START` reader"]
pub type R = crate :: R < SramReaderStartSpec > ; # [doc = "Register `SRAM_READER_START` writer"]
pub type W = crate :: W < SramReaderStartSpec > ; # [doc = "Field `sram_reader_start` reader - "]
pub type SramReaderStartR = crate :: BitReader ; # [doc = "Field `sram_reader_start` writer - "]
pub type SramReaderStartW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn sram_reader_start (& self) -> SramReaderStartR { SramReaderStartR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn sram_reader_start (& mut self) -> SramReaderStartW < SramReaderStartSpec > { SramReaderStartW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_start::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_start::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramReaderStartSpec ; impl crate :: RegisterSpec for SramReaderStartSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_reader_start::R`](R) reader structure"]
impl crate :: Readable for SramReaderStartSpec { } # [doc = "`write(|w| ..)` method takes [`sram_reader_start::W`](W) writer structure"]
impl crate :: Writable for SramReaderStartSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_READER_START to value 0"]
impl crate :: Resettable for SramReaderStartSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_READER_READY (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_ready::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_ready::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_reader_ready`]
module"]
# [doc (alias = "SRAM_READER_READY")]
pub type SramReaderReady = crate :: Reg < sram_reader_ready :: SramReaderReadySpec > ; # [doc = ""]
pub mod sram_reader_ready { # [doc = "Register `SRAM_READER_READY` reader"]
pub type R = crate :: R < SramReaderReadySpec > ; # [doc = "Register `SRAM_READER_READY` writer"]
pub type W = crate :: W < SramReaderReadySpec > ; # [doc = "Field `sram_reader_ready` reader - "]
pub type SramReaderReadyR = crate :: BitReader ; # [doc = "Field `sram_reader_ready` writer - "]
pub type SramReaderReadyW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn sram_reader_ready (& self) -> SramReaderReadyR { SramReaderReadyR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn sram_reader_ready (& mut self) -> SramReaderReadyW < SramReaderReadySpec > { SramReaderReadyW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_ready::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_ready::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramReaderReadySpec ; impl crate :: RegisterSpec for SramReaderReadySpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_reader_ready::R`](R) reader structure"]
impl crate :: Readable for SramReaderReadySpec { } # [doc = "`write(|w| ..)` method takes [`sram_reader_ready::W`](W) writer structure"]
impl crate :: Writable for SramReaderReadySpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_READER_READY to value 0"]
impl crate :: Resettable for SramReaderReadySpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_READER_LEVEL (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_level::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_level::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_reader_level`]
module"]
# [doc (alias = "SRAM_READER_LEVEL")]
pub type SramReaderLevel = crate :: Reg < sram_reader_level :: SramReaderLevelSpec > ; # [doc = ""]
pub mod sram_reader_level { # [doc = "Register `SRAM_READER_LEVEL` reader"]
pub type R = crate :: R < SramReaderLevelSpec > ; # [doc = "Register `SRAM_READER_LEVEL` writer"]
pub type W = crate :: W < SramReaderLevelSpec > ; # [doc = "Field `sram_reader_level` reader - "]
pub type SramReaderLevelR = crate :: FieldReader ; # [doc = "Field `sram_reader_level` writer - "]
pub type SramReaderLevelW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:1"]
# [inline (always)]
pub fn sram_reader_level (& self) -> SramReaderLevelR { SramReaderLevelR :: new ((self . bits & 3) as u8) } } impl W { # [doc = "Bits 0:1"]
# [inline (always)]
# [must_use]
pub fn sram_reader_level (& mut self) -> SramReaderLevelW < SramReaderLevelSpec > { SramReaderLevelW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_level::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_level::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramReaderLevelSpec ; impl crate :: RegisterSpec for SramReaderLevelSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_reader_level::R`](R) reader structure"]
impl crate :: Readable for SramReaderLevelSpec { } # [doc = "`write(|w| ..)` method takes [`sram_reader_level::W`](W) writer structure"]
impl crate :: Writable for SramReaderLevelSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_READER_LEVEL to value 0"]
impl crate :: Resettable for SramReaderLevelSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_READER_SLOT (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_slot::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_slot::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_reader_slot`]
module"]
# [doc (alias = "SRAM_READER_SLOT")]
pub type SramReaderSlot = crate :: Reg < sram_reader_slot :: SramReaderSlotSpec > ; # [doc = ""]
pub mod sram_reader_slot { # [doc = "Register `SRAM_READER_SLOT` reader"]
pub type R = crate :: R < SramReaderSlotSpec > ; # [doc = "Register `SRAM_READER_SLOT` writer"]
pub type W = crate :: W < SramReaderSlotSpec > ; # [doc = "Field `sram_reader_slot` reader - "]
pub type SramReaderSlotR = crate :: BitReader ; # [doc = "Field `sram_reader_slot` writer - "]
pub type SramReaderSlotW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn sram_reader_slot (& self) -> SramReaderSlotR { SramReaderSlotR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn sram_reader_slot (& mut self) -> SramReaderSlotW < SramReaderSlotSpec > { SramReaderSlotW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_slot::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_slot::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramReaderSlotSpec ; impl crate :: RegisterSpec for SramReaderSlotSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_reader_slot::R`](R) reader structure"]
impl crate :: Readable for SramReaderSlotSpec { } # [doc = "`write(|w| ..)` method takes [`sram_reader_slot::W`](W) writer structure"]
impl crate :: Writable for SramReaderSlotSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_READER_SLOT to value 0"]
impl crate :: Resettable for SramReaderSlotSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_READER_LENGTH (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_length::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_length::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_reader_length`]
module"]
# [doc (alias = "SRAM_READER_LENGTH")]
pub type SramReaderLength = crate :: Reg < sram_reader_length :: SramReaderLengthSpec > ; # [doc = ""]
pub mod sram_reader_length { # [doc = "Register `SRAM_READER_LENGTH` reader"]
pub type R = crate :: R < SramReaderLengthSpec > ; # [doc = "Register `SRAM_READER_LENGTH` writer"]
pub type W = crate :: W < SramReaderLengthSpec > ; # [doc = "Field `sram_reader_length` reader - "]
pub type SramReaderLengthR = crate :: FieldReader < u16 > ; # [doc = "Field `sram_reader_length` writer - "]
pub type SramReaderLengthW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ; impl R { # [doc = "Bits 0:10"]
# [inline (always)]
pub fn sram_reader_length (& self) -> SramReaderLengthR { SramReaderLengthR :: new ((self . bits & 0x07ff) as u16) } } impl W { # [doc = "Bits 0:10"]
# [inline (always)]
# [must_use]
pub fn sram_reader_length (& mut self) -> SramReaderLengthW < SramReaderLengthSpec > { SramReaderLengthW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_length::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_length::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramReaderLengthSpec ; impl crate :: RegisterSpec for SramReaderLengthSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_reader_length::R`](R) reader structure"]
impl crate :: Readable for SramReaderLengthSpec { } # [doc = "`write(|w| ..)` method takes [`sram_reader_length::W`](W) writer structure"]
impl crate :: Writable for SramReaderLengthSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_READER_LENGTH to value 0"]
impl crate :: Resettable for SramReaderLengthSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_READER_EV_STATUS (rw) register accessor: This register contains the current raw level of the event0 event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_ev_status::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_ev_status::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_reader_ev_status`]
module"]
# [doc (alias = "SRAM_READER_EV_STATUS")]
pub type SramReaderEvStatus = crate :: Reg < sram_reader_ev_status :: SramReaderEvStatusSpec > ; # [doc = "This register contains the current raw level of the event0 event trigger. Writes to this register have no effect."]
pub mod sram_reader_ev_status { # [doc = "Register `SRAM_READER_EV_STATUS` reader"]
pub type R = crate :: R < SramReaderEvStatusSpec > ; # [doc = "Register `SRAM_READER_EV_STATUS` writer"]
pub type W = crate :: W < SramReaderEvStatusSpec > ; # [doc = "Field `event0` reader - Level of the ``event0`` event"]
pub type Event0R = crate :: BitReader ; # [doc = "Field `event0` writer - Level of the ``event0`` event"]
pub type Event0W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Level of the ``event0`` event"]
# [inline (always)]
pub fn event0 (& self) -> Event0R { Event0R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Level of the ``event0`` event"]
# [inline (always)]
# [must_use]
pub fn event0 (& mut self) -> Event0W < SramReaderEvStatusSpec > { Event0W :: new (self , 0) } } # [doc = "This register contains the current raw level of the event0 event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_ev_status::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_ev_status::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramReaderEvStatusSpec ; impl crate :: RegisterSpec for SramReaderEvStatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_reader_ev_status::R`](R) reader structure"]
impl crate :: Readable for SramReaderEvStatusSpec { } # [doc = "`write(|w| ..)` method takes [`sram_reader_ev_status::W`](W) writer structure"]
impl crate :: Writable for SramReaderEvStatusSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_READER_EV_STATUS to value 0"]
impl crate :: Resettable for SramReaderEvStatusSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_READER_EV_PENDING (rw) register accessor: When a event0 event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_ev_pending::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_ev_pending::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_reader_ev_pending`]
module"]
# [doc (alias = "SRAM_READER_EV_PENDING")]
pub type SramReaderEvPending = crate :: Reg < sram_reader_ev_pending :: SramReaderEvPendingSpec > ; # [doc = "When a event0 event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub mod sram_reader_ev_pending { # [doc = "Register `SRAM_READER_EV_PENDING` reader"]
pub type R = crate :: R < SramReaderEvPendingSpec > ; # [doc = "Register `SRAM_READER_EV_PENDING` writer"]
pub type W = crate :: W < SramReaderEvPendingSpec > ; # [doc = "Field `event0` reader - `1` if a this particular event occurred. This Event is triggered on a **rising** edge."]
pub type Event0R = crate :: BitReader ; # [doc = "Field `event0` writer - `1` if a this particular event occurred. This Event is triggered on a **rising** edge."]
pub type Event0W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - `1` if a this particular event occurred. This Event is triggered on a **rising** edge."]
# [inline (always)]
pub fn event0 (& self) -> Event0R { Event0R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - `1` if a this particular event occurred. This Event is triggered on a **rising** edge."]
# [inline (always)]
# [must_use]
pub fn event0 (& mut self) -> Event0W < SramReaderEvPendingSpec > { Event0W :: new (self , 0) } } # [doc = "When a event0 event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_ev_pending::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_ev_pending::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramReaderEvPendingSpec ; impl crate :: RegisterSpec for SramReaderEvPendingSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_reader_ev_pending::R`](R) reader structure"]
impl crate :: Readable for SramReaderEvPendingSpec { } # [doc = "`write(|w| ..)` method takes [`sram_reader_ev_pending::W`](W) writer structure"]
impl crate :: Writable for SramReaderEvPendingSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_READER_EV_PENDING to value 0"]
impl crate :: Resettable for SramReaderEvPendingSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SRAM_READER_EV_ENABLE (rw) register accessor: This register enables the corresponding event0 events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_ev_enable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_ev_enable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sram_reader_ev_enable`]
module"]
# [doc (alias = "SRAM_READER_EV_ENABLE")]
pub type SramReaderEvEnable = crate :: Reg < sram_reader_ev_enable :: SramReaderEvEnableSpec > ; # [doc = "This register enables the corresponding event0 events. Write a ``0`` to this register to disable individual events."]
pub mod sram_reader_ev_enable { # [doc = "Register `SRAM_READER_EV_ENABLE` reader"]
pub type R = crate :: R < SramReaderEvEnableSpec > ; # [doc = "Register `SRAM_READER_EV_ENABLE` writer"]
pub type W = crate :: W < SramReaderEvEnableSpec > ; # [doc = "Field `event0` reader - Write a ``1`` to enable the ``event0`` Event"]
pub type Event0R = crate :: BitReader ; # [doc = "Field `event0` writer - Write a ``1`` to enable the ``event0`` Event"]
pub type Event0W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Write a ``1`` to enable the ``event0`` Event"]
# [inline (always)]
pub fn event0 (& self) -> Event0R { Event0R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Write a ``1`` to enable the ``event0`` Event"]
# [inline (always)]
# [must_use]
pub fn event0 (& mut self) -> Event0W < SramReaderEvEnableSpec > { Event0W :: new (self , 0) } } # [doc = "This register enables the corresponding event0 events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::Reg::read) this register and get [`sram_reader_ev_enable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sram_reader_ev_enable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SramReaderEvEnableSpec ; impl crate :: RegisterSpec for SramReaderEvEnableSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sram_reader_ev_enable::R`](R) reader structure"]
impl crate :: Readable for SramReaderEvEnableSpec { } # [doc = "`write(|w| ..)` method takes [`sram_reader_ev_enable::W`](W) writer structure"]
impl crate :: Writable for SramReaderEvEnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SRAM_READER_EV_ENABLE to value 0"]
impl crate :: Resettable for SramReaderEvEnableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PREAMBLE_CRC (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`preamble_crc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`preamble_crc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@preamble_crc`]
module"]
# [doc (alias = "PREAMBLE_CRC")]
pub type PreambleCrc = crate :: Reg < preamble_crc :: PreambleCrcSpec > ; # [doc = ""]
pub mod preamble_crc { # [doc = "Register `PREAMBLE_CRC` reader"]
pub type R = crate :: R < PreambleCrcSpec > ; # [doc = "Register `PREAMBLE_CRC` writer"]
pub type W = crate :: W < PreambleCrcSpec > ; # [doc = "Field `preamble_crc` reader - "]
pub type PreambleCrcR = crate :: BitReader ; # [doc = "Field `preamble_crc` writer - "]
pub type PreambleCrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn preamble_crc (& self) -> PreambleCrcR { PreambleCrcR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn preamble_crc (& mut self) -> PreambleCrcW < PreambleCrcSpec > { PreambleCrcW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`preamble_crc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`preamble_crc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct PreambleCrcSpec ; impl crate :: RegisterSpec for PreambleCrcSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`preamble_crc::R`](R) reader structure"]
impl crate :: Readable for PreambleCrcSpec { } # [doc = "`write(|w| ..)` method takes [`preamble_crc::W`](W) writer structure"]
impl crate :: Writable for PreambleCrcSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PREAMBLE_CRC to value 0x01"]
impl crate :: Resettable for PreambleCrcSpec { const RESET_VALUE : u32 = 0x01 ; } } # [doc = "RX_DATAPATH_PREAMBLE_ERRORS (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`rx_datapath_preamble_errors::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rx_datapath_preamble_errors::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_datapath_preamble_errors`]
module"]
# [doc (alias = "RX_DATAPATH_PREAMBLE_ERRORS")]
pub type RxDatapathPreambleErrors = crate :: Reg < rx_datapath_preamble_errors :: RxDatapathPreambleErrorsSpec > ; # [doc = ""]
pub mod rx_datapath_preamble_errors { # [doc = "Register `RX_DATAPATH_PREAMBLE_ERRORS` reader"]
pub type R = crate :: R < RxDatapathPreambleErrorsSpec > ; # [doc = "Register `RX_DATAPATH_PREAMBLE_ERRORS` writer"]
pub type W = crate :: W < RxDatapathPreambleErrorsSpec > ; # [doc = "Field `rx_datapath_preamble_errors` reader - "]
pub type RxDatapathPreambleErrorsR = crate :: FieldReader < u32 > ; # [doc = "Field `rx_datapath_preamble_errors` writer - "]
pub type RxDatapathPreambleErrorsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn rx_datapath_preamble_errors (& self) -> RxDatapathPreambleErrorsR { RxDatapathPreambleErrorsR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn rx_datapath_preamble_errors (& mut self) -> RxDatapathPreambleErrorsW < RxDatapathPreambleErrorsSpec > { RxDatapathPreambleErrorsW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_datapath_preamble_errors::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rx_datapath_preamble_errors::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxDatapathPreambleErrorsSpec ; impl crate :: RegisterSpec for RxDatapathPreambleErrorsSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rx_datapath_preamble_errors::R`](R) reader structure"]
impl crate :: Readable for RxDatapathPreambleErrorsSpec { } # [doc = "`write(|w| ..)` method takes [`rx_datapath_preamble_errors::W`](W) writer structure"]
impl crate :: Writable for RxDatapathPreambleErrorsSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RX_DATAPATH_PREAMBLE_ERRORS to value 0"]
impl crate :: Resettable for RxDatapathPreambleErrorsSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RX_DATAPATH_CRC_ERRORS (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`rx_datapath_crc_errors::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rx_datapath_crc_errors::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_datapath_crc_errors`]
module"]
# [doc (alias = "RX_DATAPATH_CRC_ERRORS")]
pub type RxDatapathCrcErrors = crate :: Reg < rx_datapath_crc_errors :: RxDatapathCrcErrorsSpec > ; # [doc = ""]
pub mod rx_datapath_crc_errors { # [doc = "Register `RX_DATAPATH_CRC_ERRORS` reader"]
pub type R = crate :: R < RxDatapathCrcErrorsSpec > ; # [doc = "Register `RX_DATAPATH_CRC_ERRORS` writer"]
pub type W = crate :: W < RxDatapathCrcErrorsSpec > ; # [doc = "Field `rx_datapath_crc_errors` reader - "]
pub type RxDatapathCrcErrorsR = crate :: FieldReader < u32 > ; # [doc = "Field `rx_datapath_crc_errors` writer - "]
pub type RxDatapathCrcErrorsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn rx_datapath_crc_errors (& self) -> RxDatapathCrcErrorsR { RxDatapathCrcErrorsR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn rx_datapath_crc_errors (& mut self) -> RxDatapathCrcErrorsW < RxDatapathCrcErrorsSpec > { RxDatapathCrcErrorsW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_datapath_crc_errors::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rx_datapath_crc_errors::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxDatapathCrcErrorsSpec ; impl crate :: RegisterSpec for RxDatapathCrcErrorsSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rx_datapath_crc_errors::R`](R) reader structure"]
impl crate :: Readable for RxDatapathCrcErrorsSpec { } # [doc = "`write(|w| ..)` method takes [`rx_datapath_crc_errors::W`](W) writer structure"]
impl crate :: Writable for RxDatapathCrcErrorsSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RX_DATAPATH_CRC_ERRORS to value 0"]
impl crate :: Resettable for RxDatapathCrcErrorsSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "IP_ADDRESS (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`ip_address::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ip_address::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ip_address`]
module"]
# [doc (alias = "IP_ADDRESS")]
pub type IpAddress = crate :: Reg < ip_address :: IpAddressSpec > ; # [doc = ""]
pub mod ip_address { # [doc = "Register `IP_ADDRESS` reader"]
pub type R = crate :: R < IpAddressSpec > ; # [doc = "Register `IP_ADDRESS` writer"]
pub type W = crate :: W < IpAddressSpec > ; # [doc = "Field `ip_address` reader - "]
pub type IpAddressR = crate :: FieldReader < u32 > ; # [doc = "Field `ip_address` writer - "]
pub type IpAddressW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn ip_address (& self) -> IpAddressR { IpAddressR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn ip_address (& mut self) -> IpAddressW < IpAddressSpec > { IpAddressW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`ip_address::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ip_address::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IpAddressSpec ; impl crate :: RegisterSpec for IpAddressSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ip_address::R`](R) reader structure"]
impl crate :: Readable for IpAddressSpec { } # [doc = "`write(|w| ..)` method takes [`ip_address::W`](W) writer structure"]
impl crate :: Writable for IpAddressSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets IP_ADDRESS to value 0xc0a8_0132"]
impl crate :: Resettable for IpAddressSpec { const RESET_VALUE : u32 = 0xc0a8_0132 ; } } # [doc = "MAC_ADDRESS1 (rw) register accessor: Bits 32-47 of `ETHMAC_MAC_ADDRESS`. The value won't take effect until `ETHMAC_MAC_ADDRESS0` is written.\n\nYou can [`read`](crate::Reg::read) this register and get [`mac_address1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mac_address1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mac_address1`]
module"]
# [doc (alias = "MAC_ADDRESS1")]
pub type MacAddress1 = crate :: Reg < mac_address1 :: MacAddress1Spec > ; # [doc = "Bits 32-47 of `ETHMAC_MAC_ADDRESS`. The value won't take effect until `ETHMAC_MAC_ADDRESS0` is written."]
pub mod mac_address1 { # [doc = "Register `MAC_ADDRESS1` reader"]
pub type R = crate :: R < MacAddress1Spec > ; # [doc = "Register `MAC_ADDRESS1` writer"]
pub type W = crate :: W < MacAddress1Spec > ; # [doc = "Field `mac_address` reader - "]
pub type MacAddressR = crate :: FieldReader < u32 > ; # [doc = "Field `mac_address` writer - "]
pub type MacAddressW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn mac_address (& self) -> MacAddressR { MacAddressR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn mac_address (& mut self) -> MacAddressW < MacAddress1Spec > { MacAddressW :: new (self , 0) } } # [doc = "Bits 32-47 of `ETHMAC_MAC_ADDRESS`. The value won't take effect until `ETHMAC_MAC_ADDRESS0` is written.\n\nYou can [`read`](crate::Reg::read) this register and get [`mac_address1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mac_address1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MacAddress1Spec ; impl crate :: RegisterSpec for MacAddress1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`mac_address1::R`](R) reader structure"]
impl crate :: Readable for MacAddress1Spec { } # [doc = "`write(|w| ..)` method takes [`mac_address1::W`](W) writer structure"]
impl crate :: Writable for MacAddress1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MAC_ADDRESS1 to value 0x7648"]
impl crate :: Resettable for MacAddress1Spec { const RESET_VALUE : u32 = 0x7648 ; } } # [doc = "MAC_ADDRESS0 (rw) register accessor: Bits 0-31 of `ETHMAC_MAC_ADDRESS`. Writing this register triggers an update of `ETHMAC_MAC_ADDRESS`.\n\nYou can [`read`](crate::Reg::read) this register and get [`mac_address0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mac_address0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mac_address0`]
module"]
# [doc (alias = "MAC_ADDRESS0")]
pub type MacAddress0 = crate :: Reg < mac_address0 :: MacAddress0Spec > ; # [doc = "Bits 0-31 of `ETHMAC_MAC_ADDRESS`. Writing this register triggers an update of `ETHMAC_MAC_ADDRESS`."]
pub mod mac_address0 { # [doc = "Register `MAC_ADDRESS0` reader"]
pub type R = crate :: R < MacAddress0Spec > ; # [doc = "Register `MAC_ADDRESS0` writer"]
pub type W = crate :: W < MacAddress0Spec > ; # [doc = "Field `mac_address` reader - "]
pub type MacAddressR = crate :: FieldReader < u32 > ; # [doc = "Field `mac_address` writer - "]
pub type MacAddressW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn mac_address (& self) -> MacAddressR { MacAddressR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn mac_address (& mut self) -> MacAddressW < MacAddress0Spec > { MacAddressW :: new (self , 0) } } # [doc = "Bits 0-31 of `ETHMAC_MAC_ADDRESS`. Writing this register triggers an update of `ETHMAC_MAC_ADDRESS`.\n\nYou can [`read`](crate::Reg::read) this register and get [`mac_address0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mac_address0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MacAddress0Spec ; impl crate :: RegisterSpec for MacAddress0Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`mac_address0::R`](R) reader structure"]
impl crate :: Readable for MacAddress0Spec { } # [doc = "`write(|w| ..)` method takes [`mac_address0::W`](W) writer structure"]
impl crate :: Writable for MacAddress0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MAC_ADDRESS0 to value 0x74c8_c483"]
impl crate :: Resettable for MacAddress0Spec { const RESET_VALUE : u32 = 0x74c8_c483 ; } } } # [doc = "ETHPHY"]
pub struct Ethphy { _marker : PhantomData < * const () > } unsafe impl Send for Ethphy { } impl Ethphy { # [doc = r"Pointer to the register block"]
pub const PTR : * const ethphy :: RegisterBlock = 0xf000_2000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ethphy :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Ethphy { type Target = ethphy :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Ethphy { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ethphy") . finish () } } # [doc = "ETHPHY"]
pub mod ethphy { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { crg_reset : CrgReset , rx_inband_status : RxInbandStatus , mdio_w : MdioW , mdio_r : MdioR , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn crg_reset (& self) -> & CrgReset { & self . crg_reset } # [doc = "0x04 - "]
# [inline (always)]
pub const fn rx_inband_status (& self) -> & RxInbandStatus { & self . rx_inband_status } # [doc = "0x08 - "]
# [inline (always)]
pub const fn mdio_w (& self) -> & MdioW { & self . mdio_w } # [doc = "0x0c - "]
# [inline (always)]
pub const fn mdio_r (& self) -> & MdioR { & self . mdio_r } } # [doc = "CRG_RESET (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`crg_reset::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crg_reset::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@crg_reset`]
module"]
# [doc (alias = "CRG_RESET")]
pub type CrgReset = crate :: Reg < crg_reset :: CrgResetSpec > ; # [doc = ""]
pub mod crg_reset { # [doc = "Register `CRG_RESET` reader"]
pub type R = crate :: R < CrgResetSpec > ; # [doc = "Register `CRG_RESET` writer"]
pub type W = crate :: W < CrgResetSpec > ; # [doc = "Field `crg_reset` reader - "]
pub type CrgResetR = crate :: BitReader ; # [doc = "Field `crg_reset` writer - "]
pub type CrgResetW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn crg_reset (& self) -> CrgResetR { CrgResetR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn crg_reset (& mut self) -> CrgResetW < CrgResetSpec > { CrgResetW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`crg_reset::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crg_reset::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CrgResetSpec ; impl crate :: RegisterSpec for CrgResetSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`crg_reset::R`](R) reader structure"]
impl crate :: Readable for CrgResetSpec { } # [doc = "`write(|w| ..)` method takes [`crg_reset::W`](W) writer structure"]
impl crate :: Writable for CrgResetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CRG_RESET to value 0"]
impl crate :: Resettable for CrgResetSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RX_INBAND_STATUS (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`rx_inband_status::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rx_inband_status::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_inband_status`]
module"]
# [doc (alias = "RX_INBAND_STATUS")]
pub type RxInbandStatus = crate :: Reg < rx_inband_status :: RxInbandStatusSpec > ; # [doc = ""]
pub mod rx_inband_status { # [doc = "Register `RX_INBAND_STATUS` reader"]
pub type R = crate :: R < RxInbandStatusSpec > ; # [doc = "Register `RX_INBAND_STATUS` writer"]
pub type W = crate :: W < RxInbandStatusSpec > ; # [doc = "Field `link_status` reader - None"]
pub type LinkStatusR = crate :: BitReader ; # [doc = "Field `link_status` writer - None"]
pub type LinkStatusW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `clock_speed` reader - None"]
pub type ClockSpeedR = crate :: FieldReader ; # [doc = "Field `clock_speed` writer - None"]
pub type ClockSpeedW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; # [doc = "Field `duplex_status` reader - None"]
pub type DuplexStatusR = crate :: BitReader ; # [doc = "Field `duplex_status` writer - None"]
pub type DuplexStatusW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - None"]
# [inline (always)]
pub fn link_status (& self) -> LinkStatusR { LinkStatusR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - None"]
# [inline (always)]
pub fn clock_speed (& self) -> ClockSpeedR { ClockSpeedR :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bit 3 - None"]
# [inline (always)]
pub fn duplex_status (& self) -> DuplexStatusR { DuplexStatusR :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - None"]
# [inline (always)]
# [must_use]
pub fn link_status (& mut self) -> LinkStatusW < RxInbandStatusSpec > { LinkStatusW :: new (self , 0) } # [doc = "Bits 1:2 - None"]
# [inline (always)]
# [must_use]
pub fn clock_speed (& mut self) -> ClockSpeedW < RxInbandStatusSpec > { ClockSpeedW :: new (self , 1) } # [doc = "Bit 3 - None"]
# [inline (always)]
# [must_use]
pub fn duplex_status (& mut self) -> DuplexStatusW < RxInbandStatusSpec > { DuplexStatusW :: new (self , 3) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_inband_status::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rx_inband_status::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxInbandStatusSpec ; impl crate :: RegisterSpec for RxInbandStatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rx_inband_status::R`](R) reader structure"]
impl crate :: Readable for RxInbandStatusSpec { } # [doc = "`write(|w| ..)` method takes [`rx_inband_status::W`](W) writer structure"]
impl crate :: Writable for RxInbandStatusSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RX_INBAND_STATUS to value 0"]
impl crate :: Resettable for RxInbandStatusSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MDIO_W (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`mdio_w::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdio_w::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mdio_w`]
module"]
# [doc (alias = "MDIO_W")]
pub type MdioW = crate :: Reg < mdio_w :: MdioWSpec > ; # [doc = ""]
pub mod mdio_w { # [doc = "Register `MDIO_W` reader"]
pub type R = crate :: R < MdioWSpec > ; # [doc = "Register `MDIO_W` writer"]
pub type W = crate :: W < MdioWSpec > ; # [doc = "Field `mdc` reader - None"]
pub type MdcR = crate :: BitReader ; # [doc = "Field `mdc` writer - None"]
pub type MdcW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `oe` reader - None"]
pub type OeR = crate :: BitReader ; # [doc = "Field `oe` writer - None"]
pub type OeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `w` reader - None"]
pub type WR = crate :: BitReader ; # [doc = "Field `w` writer - None"]
pub type WW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - None"]
# [inline (always)]
pub fn mdc (& self) -> MdcR { MdcR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - None"]
# [inline (always)]
pub fn oe (& self) -> OeR { OeR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - None"]
# [inline (always)]
pub fn w (& self) -> WR { WR :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - None"]
# [inline (always)]
# [must_use]
pub fn mdc (& mut self) -> MdcW < MdioWSpec > { MdcW :: new (self , 0) } # [doc = "Bit 1 - None"]
# [inline (always)]
# [must_use]
pub fn oe (& mut self) -> OeW < MdioWSpec > { OeW :: new (self , 1) } # [doc = "Bit 2 - None"]
# [inline (always)]
# [must_use]
pub fn w (& mut self) -> WW < MdioWSpec > { WW :: new (self , 2) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`mdio_w::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdio_w::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MdioWSpec ; impl crate :: RegisterSpec for MdioWSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mdio_w::R`](R) reader structure"]
impl crate :: Readable for MdioWSpec { } # [doc = "`write(|w| ..)` method takes [`mdio_w::W`](W) writer structure"]
impl crate :: Writable for MdioWSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MDIO_W to value 0"]
impl crate :: Resettable for MdioWSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MDIO_R (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`mdio_r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdio_r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mdio_r`]
module"]
# [doc (alias = "MDIO_R")]
pub type MdioR = crate :: Reg < mdio_r :: MdioRSpec > ; # [doc = ""]
pub mod mdio_r { # [doc = "Register `MDIO_R` reader"]
pub type R = crate :: R < MdioRSpec > ; # [doc = "Register `MDIO_R` writer"]
pub type W = crate :: W < MdioRSpec > ; # [doc = "Field `r` reader - None"]
pub type RR = crate :: BitReader ; # [doc = "Field `r` writer - None"]
pub type RW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - None"]
# [inline (always)]
pub fn r (& self) -> RR { RR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - None"]
# [inline (always)]
# [must_use]
pub fn r (& mut self) -> RW < MdioRSpec > { RW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`mdio_r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdio_r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MdioRSpec ; impl crate :: RegisterSpec for MdioRSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mdio_r::R`](R) reader structure"]
impl crate :: Readable for MdioRSpec { } # [doc = "`write(|w| ..)` method takes [`mdio_r::W`](W) writer structure"]
impl crate :: Writable for MdioRSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MDIO_R to value 0"]
impl crate :: Resettable for MdioRSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "HUB75_PALETTE"]
pub struct Hub75Palette { _marker : PhantomData < * const () > } unsafe impl Send for Hub75Palette { } impl Hub75Palette { # [doc = r"Pointer to the register block"]
pub const PTR : * const hub75_palette :: RegisterBlock = 0xf000_2800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const hub75_palette :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Hub75Palette { type Target = hub75_palette :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Hub75Palette { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Hub75Palette") . finish () } } # [doc = "HUB75_PALETTE"]
pub mod hub75_palette { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { hub75_palette : Hub75Palette , } impl RegisterBlock { # [doc = "0x00 - 32 x 256-bit memory"]
# [inline (always)]
pub const fn hub75_palette (& self) -> & Hub75Palette { & self . hub75_palette } } # [doc = "HUB75_PALETTE (rw) register accessor: 32 x 256-bit memory\n\nYou can [`read`](crate::Reg::read) this register and get [`hub75_palette::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hub75_palette::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hub75_palette`]
module"]
# [doc (alias = "HUB75_PALETTE")]
pub type Hub75Palette = crate :: Reg < hub75_palette :: Hub75PaletteSpec > ; # [doc = "32 x 256-bit memory"]
pub mod hub75_palette { # [doc = "Register `HUB75_PALETTE` reader"]
pub type R = crate :: R < Hub75PaletteSpec > ; # [doc = "Register `HUB75_PALETTE` writer"]
pub type W = crate :: W < Hub75PaletteSpec > ; # [doc = "Field `hub75_palette` reader - "]
pub type Hub75PaletteR = crate :: FieldReader < u32 > ; # [doc = "Field `hub75_palette` writer - "]
pub type Hub75PaletteW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn hub75_palette (& self) -> Hub75PaletteR { Hub75PaletteR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn hub75_palette (& mut self) -> Hub75PaletteW < Hub75PaletteSpec > { Hub75PaletteW :: new (self , 0) } } # [doc = "32 x 256-bit memory\n\nYou can [`read`](crate::Reg::read) this register and get [`hub75_palette::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hub75_palette::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Hub75PaletteSpec ; impl crate :: RegisterSpec for Hub75PaletteSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`hub75_palette::R`](R) reader structure"]
impl crate :: Readable for Hub75PaletteSpec { } # [doc = "`write(|w| ..)` method takes [`hub75_palette::W`](W) writer structure"]
impl crate :: Writable for Hub75PaletteSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets HUB75_PALETTE to value 0"]
impl crate :: Resettable for Hub75PaletteSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "HUB75"]
pub struct Hub75 { _marker : PhantomData < * const () > } unsafe impl Send for Hub75 { } impl Hub75 { # [doc = r"Pointer to the register block"]
pub const PTR : * const hub75 :: RegisterBlock = 0xf000_3000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const hub75 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Hub75 { type Target = hub75 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Hub75 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Hub75") . finish () } } # [doc = "HUB75"]
pub mod hub75 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { ctrl : Ctrl , panel0_0 : Panel0_0 , panel0_1 : Panel0_1 , panel0_2 : Panel0_2 , panel0_3 : Panel0_3 , panel1_0 : Panel1_0 , panel1_1 : Panel1_1 , panel1_2 : Panel1_2 , panel1_3 : Panel1_3 , panel2_0 : Panel2_0 , panel2_1 : Panel2_1 , panel2_2 : Panel2_2 , panel2_3 : Panel2_3 , panel3_0 : Panel3_0 , panel3_1 : Panel3_1 , panel3_2 : Panel3_2 , panel3_3 : Panel3_3 , panel4_0 : Panel4_0 , panel4_1 : Panel4_1 , panel4_2 : Panel4_2 , panel4_3 : Panel4_3 , panel5_0 : Panel5_0 , panel5_1 : Panel5_1 , panel5_2 : Panel5_2 , panel5_3 : Panel5_3 , panel6_0 : Panel6_0 , panel6_1 : Panel6_1 , panel6_2 : Panel6_2 , panel6_3 : Panel6_3 , panel7_0 : Panel7_0 , panel7_1 : Panel7_1 , panel7_2 : Panel7_2 , panel7_3 : Panel7_3 , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn ctrl (& self) -> & Ctrl { & self . ctrl } # [doc = "0x04 - "]
# [inline (always)]
pub const fn panel0_0 (& self) -> & Panel0_0 { & self . panel0_0 } # [doc = "0x08 - "]
# [inline (always)]
pub const fn panel0_1 (& self) -> & Panel0_1 { & self . panel0_1 } # [doc = "0x0c - "]
# [inline (always)]
pub const fn panel0_2 (& self) -> & Panel0_2 { & self . panel0_2 } # [doc = "0x10 - "]
# [inline (always)]
pub const fn panel0_3 (& self) -> & Panel0_3 { & self . panel0_3 } # [doc = "0x14 - "]
# [inline (always)]
pub const fn panel1_0 (& self) -> & Panel1_0 { & self . panel1_0 } # [doc = "0x18 - "]
# [inline (always)]
pub const fn panel1_1 (& self) -> & Panel1_1 { & self . panel1_1 } # [doc = "0x1c - "]
# [inline (always)]
pub const fn panel1_2 (& self) -> & Panel1_2 { & self . panel1_2 } # [doc = "0x20 - "]
# [inline (always)]
pub const fn panel1_3 (& self) -> & Panel1_3 { & self . panel1_3 } # [doc = "0x24 - "]
# [inline (always)]
pub const fn panel2_0 (& self) -> & Panel2_0 { & self . panel2_0 } # [doc = "0x28 - "]
# [inline (always)]
pub const fn panel2_1 (& self) -> & Panel2_1 { & self . panel2_1 } # [doc = "0x2c - "]
# [inline (always)]
pub const fn panel2_2 (& self) -> & Panel2_2 { & self . panel2_2 } # [doc = "0x30 - "]
# [inline (always)]
pub const fn panel2_3 (& self) -> & Panel2_3 { & self . panel2_3 } # [doc = "0x34 - "]
# [inline (always)]
pub const fn panel3_0 (& self) -> & Panel3_0 { & self . panel3_0 } # [doc = "0x38 - "]
# [inline (always)]
pub const fn panel3_1 (& self) -> & Panel3_1 { & self . panel3_1 } # [doc = "0x3c - "]
# [inline (always)]
pub const fn panel3_2 (& self) -> & Panel3_2 { & self . panel3_2 } # [doc = "0x40 - "]
# [inline (always)]
pub const fn panel3_3 (& self) -> & Panel3_3 { & self . panel3_3 } # [doc = "0x44 - "]
# [inline (always)]
pub const fn panel4_0 (& self) -> & Panel4_0 { & self . panel4_0 } # [doc = "0x48 - "]
# [inline (always)]
pub const fn panel4_1 (& self) -> & Panel4_1 { & self . panel4_1 } # [doc = "0x4c - "]
# [inline (always)]
pub const fn panel4_2 (& self) -> & Panel4_2 { & self . panel4_2 } # [doc = "0x50 - "]
# [inline (always)]
pub const fn panel4_3 (& self) -> & Panel4_3 { & self . panel4_3 } # [doc = "0x54 - "]
# [inline (always)]
pub const fn panel5_0 (& self) -> & Panel5_0 { & self . panel5_0 } # [doc = "0x58 - "]
# [inline (always)]
pub const fn panel5_1 (& self) -> & Panel5_1 { & self . panel5_1 } # [doc = "0x5c - "]
# [inline (always)]
pub const fn panel5_2 (& self) -> & Panel5_2 { & self . panel5_2 } # [doc = "0x60 - "]
# [inline (always)]
pub const fn panel5_3 (& self) -> & Panel5_3 { & self . panel5_3 } # [doc = "0x64 - "]
# [inline (always)]
pub const fn panel6_0 (& self) -> & Panel6_0 { & self . panel6_0 } # [doc = "0x68 - "]
# [inline (always)]
pub const fn panel6_1 (& self) -> & Panel6_1 { & self . panel6_1 } # [doc = "0x6c - "]
# [inline (always)]
pub const fn panel6_2 (& self) -> & Panel6_2 { & self . panel6_2 } # [doc = "0x70 - "]
# [inline (always)]
pub const fn panel6_3 (& self) -> & Panel6_3 { & self . panel6_3 } # [doc = "0x74 - "]
# [inline (always)]
pub const fn panel7_0 (& self) -> & Panel7_0 { & self . panel7_0 } # [doc = "0x78 - "]
# [inline (always)]
pub const fn panel7_1 (& self) -> & Panel7_1 { & self . panel7_1 } # [doc = "0x7c - "]
# [inline (always)]
pub const fn panel7_2 (& self) -> & Panel7_2 { & self . panel7_2 } # [doc = "0x80 - "]
# [inline (always)]
pub const fn panel7_3 (& self) -> & Panel7_3 { & self . panel7_3 } } # [doc = "CTRL (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`]
module"]
# [doc (alias = "CTRL")]
pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ; # [doc = ""]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub type R = crate :: R < CtrlSpec > ; # [doc = "Register `CTRL` writer"]
pub type W = crate :: W < CtrlSpec > ; # [doc = "Field `indexed` reader - Display an indexed image"]
pub type IndexedR = crate :: BitReader ; # [doc = "Field `indexed` writer - Display an indexed image"]
pub type IndexedW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `enabled` reader - Enable the output"]
pub type EnabledR = crate :: BitReader ; # [doc = "Field `enabled` writer - Enable the output"]
pub type EnabledW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `width` reader - Width of the image"]
pub type WidthR = crate :: FieldReader < u16 > ; # [doc = "Field `width` writer - Width of the image"]
pub type WidthW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bit 0 - Display an indexed image"]
# [inline (always)]
pub fn indexed (& self) -> IndexedR { IndexedR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable the output"]
# [inline (always)]
pub fn enabled (& self) -> EnabledR { EnabledR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:17 - Width of the image"]
# [inline (always)]
pub fn width (& self) -> WidthR { WidthR :: new (((self . bits >> 2) & 0xffff) as u16) } } impl W { # [doc = "Bit 0 - Display an indexed image"]
# [inline (always)]
# [must_use]
pub fn indexed (& mut self) -> IndexedW < CtrlSpec > { IndexedW :: new (self , 0) } # [doc = "Bit 1 - Enable the output"]
# [inline (always)]
# [must_use]
pub fn enabled (& mut self) -> EnabledW < CtrlSpec > { EnabledW :: new (self , 1) } # [doc = "Bits 2:17 - Width of the image"]
# [inline (always)]
# [must_use]
pub fn width (& mut self) -> WidthW < CtrlSpec > { WidthW :: new (self , 2) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ctrl::R`](R) reader structure"]
impl crate :: Readable for CtrlSpec { } # [doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"]
impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CtrlSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL0_0 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel0_0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel0_0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel0_0`]
module"]
# [doc (alias = "PANEL0_0")]
pub type Panel0_0 = crate :: Reg < panel0_0 :: Panel0_0Spec > ; # [doc = ""]
pub mod panel0_0 { # [doc = "Register `PANEL0_0` reader"]
pub type R = crate :: R < Panel0_0Spec > ; # [doc = "Register `PANEL0_0` writer"]
pub type W = crate :: W < Panel0_0Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel0_0Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel0_0Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel0_0Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel0_0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel0_0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel0_0Spec ; impl crate :: RegisterSpec for Panel0_0Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel0_0::R`](R) reader structure"]
impl crate :: Readable for Panel0_0Spec { } # [doc = "`write(|w| ..)` method takes [`panel0_0::W`](W) writer structure"]
impl crate :: Writable for Panel0_0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL0_0 to value 0"]
impl crate :: Resettable for Panel0_0Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL0_1 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel0_1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel0_1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel0_1`]
module"]
# [doc (alias = "PANEL0_1")]
pub type Panel0_1 = crate :: Reg < panel0_1 :: Panel0_1Spec > ; # [doc = ""]
pub mod panel0_1 { # [doc = "Register `PANEL0_1` reader"]
pub type R = crate :: R < Panel0_1Spec > ; # [doc = "Register `PANEL0_1` writer"]
pub type W = crate :: W < Panel0_1Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel0_1Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel0_1Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel0_1Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel0_1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel0_1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel0_1Spec ; impl crate :: RegisterSpec for Panel0_1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel0_1::R`](R) reader structure"]
impl crate :: Readable for Panel0_1Spec { } # [doc = "`write(|w| ..)` method takes [`panel0_1::W`](W) writer structure"]
impl crate :: Writable for Panel0_1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL0_1 to value 0"]
impl crate :: Resettable for Panel0_1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL0_2 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel0_2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel0_2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel0_2`]
module"]
# [doc (alias = "PANEL0_2")]
pub type Panel0_2 = crate :: Reg < panel0_2 :: Panel0_2Spec > ; # [doc = ""]
pub mod panel0_2 { # [doc = "Register `PANEL0_2` reader"]
pub type R = crate :: R < Panel0_2Spec > ; # [doc = "Register `PANEL0_2` writer"]
pub type W = crate :: W < Panel0_2Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel0_2Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel0_2Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel0_2Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel0_2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel0_2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel0_2Spec ; impl crate :: RegisterSpec for Panel0_2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel0_2::R`](R) reader structure"]
impl crate :: Readable for Panel0_2Spec { } # [doc = "`write(|w| ..)` method takes [`panel0_2::W`](W) writer structure"]
impl crate :: Writable for Panel0_2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL0_2 to value 0"]
impl crate :: Resettable for Panel0_2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL0_3 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel0_3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel0_3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel0_3`]
module"]
# [doc (alias = "PANEL0_3")]
pub type Panel0_3 = crate :: Reg < panel0_3 :: Panel0_3Spec > ; # [doc = ""]
pub mod panel0_3 { # [doc = "Register `PANEL0_3` reader"]
pub type R = crate :: R < Panel0_3Spec > ; # [doc = "Register `PANEL0_3` writer"]
pub type W = crate :: W < Panel0_3Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel0_3Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel0_3Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel0_3Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel0_3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel0_3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel0_3Spec ; impl crate :: RegisterSpec for Panel0_3Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel0_3::R`](R) reader structure"]
impl crate :: Readable for Panel0_3Spec { } # [doc = "`write(|w| ..)` method takes [`panel0_3::W`](W) writer structure"]
impl crate :: Writable for Panel0_3Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL0_3 to value 0"]
impl crate :: Resettable for Panel0_3Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL1_0 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel1_0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel1_0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel1_0`]
module"]
# [doc (alias = "PANEL1_0")]
pub type Panel1_0 = crate :: Reg < panel1_0 :: Panel1_0Spec > ; # [doc = ""]
pub mod panel1_0 { # [doc = "Register `PANEL1_0` reader"]
pub type R = crate :: R < Panel1_0Spec > ; # [doc = "Register `PANEL1_0` writer"]
pub type W = crate :: W < Panel1_0Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel1_0Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel1_0Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel1_0Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel1_0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel1_0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel1_0Spec ; impl crate :: RegisterSpec for Panel1_0Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel1_0::R`](R) reader structure"]
impl crate :: Readable for Panel1_0Spec { } # [doc = "`write(|w| ..)` method takes [`panel1_0::W`](W) writer structure"]
impl crate :: Writable for Panel1_0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL1_0 to value 0"]
impl crate :: Resettable for Panel1_0Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL1_1 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel1_1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel1_1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel1_1`]
module"]
# [doc (alias = "PANEL1_1")]
pub type Panel1_1 = crate :: Reg < panel1_1 :: Panel1_1Spec > ; # [doc = ""]
pub mod panel1_1 { # [doc = "Register `PANEL1_1` reader"]
pub type R = crate :: R < Panel1_1Spec > ; # [doc = "Register `PANEL1_1` writer"]
pub type W = crate :: W < Panel1_1Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel1_1Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel1_1Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel1_1Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel1_1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel1_1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel1_1Spec ; impl crate :: RegisterSpec for Panel1_1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel1_1::R`](R) reader structure"]
impl crate :: Readable for Panel1_1Spec { } # [doc = "`write(|w| ..)` method takes [`panel1_1::W`](W) writer structure"]
impl crate :: Writable for Panel1_1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL1_1 to value 0"]
impl crate :: Resettable for Panel1_1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL1_2 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel1_2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel1_2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel1_2`]
module"]
# [doc (alias = "PANEL1_2")]
pub type Panel1_2 = crate :: Reg < panel1_2 :: Panel1_2Spec > ; # [doc = ""]
pub mod panel1_2 { # [doc = "Register `PANEL1_2` reader"]
pub type R = crate :: R < Panel1_2Spec > ; # [doc = "Register `PANEL1_2` writer"]
pub type W = crate :: W < Panel1_2Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel1_2Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel1_2Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel1_2Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel1_2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel1_2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel1_2Spec ; impl crate :: RegisterSpec for Panel1_2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel1_2::R`](R) reader structure"]
impl crate :: Readable for Panel1_2Spec { } # [doc = "`write(|w| ..)` method takes [`panel1_2::W`](W) writer structure"]
impl crate :: Writable for Panel1_2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL1_2 to value 0"]
impl crate :: Resettable for Panel1_2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL1_3 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel1_3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel1_3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel1_3`]
module"]
# [doc (alias = "PANEL1_3")]
pub type Panel1_3 = crate :: Reg < panel1_3 :: Panel1_3Spec > ; # [doc = ""]
pub mod panel1_3 { # [doc = "Register `PANEL1_3` reader"]
pub type R = crate :: R < Panel1_3Spec > ; # [doc = "Register `PANEL1_3` writer"]
pub type W = crate :: W < Panel1_3Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel1_3Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel1_3Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel1_3Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel1_3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel1_3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel1_3Spec ; impl crate :: RegisterSpec for Panel1_3Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel1_3::R`](R) reader structure"]
impl crate :: Readable for Panel1_3Spec { } # [doc = "`write(|w| ..)` method takes [`panel1_3::W`](W) writer structure"]
impl crate :: Writable for Panel1_3Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL1_3 to value 0"]
impl crate :: Resettable for Panel1_3Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL2_0 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel2_0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel2_0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel2_0`]
module"]
# [doc (alias = "PANEL2_0")]
pub type Panel2_0 = crate :: Reg < panel2_0 :: Panel2_0Spec > ; # [doc = ""]
pub mod panel2_0 { # [doc = "Register `PANEL2_0` reader"]
pub type R = crate :: R < Panel2_0Spec > ; # [doc = "Register `PANEL2_0` writer"]
pub type W = crate :: W < Panel2_0Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel2_0Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel2_0Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel2_0Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel2_0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel2_0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel2_0Spec ; impl crate :: RegisterSpec for Panel2_0Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel2_0::R`](R) reader structure"]
impl crate :: Readable for Panel2_0Spec { } # [doc = "`write(|w| ..)` method takes [`panel2_0::W`](W) writer structure"]
impl crate :: Writable for Panel2_0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL2_0 to value 0"]
impl crate :: Resettable for Panel2_0Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL2_1 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel2_1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel2_1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel2_1`]
module"]
# [doc (alias = "PANEL2_1")]
pub type Panel2_1 = crate :: Reg < panel2_1 :: Panel2_1Spec > ; # [doc = ""]
pub mod panel2_1 { # [doc = "Register `PANEL2_1` reader"]
pub type R = crate :: R < Panel2_1Spec > ; # [doc = "Register `PANEL2_1` writer"]
pub type W = crate :: W < Panel2_1Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel2_1Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel2_1Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel2_1Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel2_1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel2_1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel2_1Spec ; impl crate :: RegisterSpec for Panel2_1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel2_1::R`](R) reader structure"]
impl crate :: Readable for Panel2_1Spec { } # [doc = "`write(|w| ..)` method takes [`panel2_1::W`](W) writer structure"]
impl crate :: Writable for Panel2_1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL2_1 to value 0"]
impl crate :: Resettable for Panel2_1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL2_2 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel2_2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel2_2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel2_2`]
module"]
# [doc (alias = "PANEL2_2")]
pub type Panel2_2 = crate :: Reg < panel2_2 :: Panel2_2Spec > ; # [doc = ""]
pub mod panel2_2 { # [doc = "Register `PANEL2_2` reader"]
pub type R = crate :: R < Panel2_2Spec > ; # [doc = "Register `PANEL2_2` writer"]
pub type W = crate :: W < Panel2_2Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel2_2Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel2_2Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel2_2Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel2_2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel2_2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel2_2Spec ; impl crate :: RegisterSpec for Panel2_2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel2_2::R`](R) reader structure"]
impl crate :: Readable for Panel2_2Spec { } # [doc = "`write(|w| ..)` method takes [`panel2_2::W`](W) writer structure"]
impl crate :: Writable for Panel2_2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL2_2 to value 0"]
impl crate :: Resettable for Panel2_2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL2_3 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel2_3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel2_3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel2_3`]
module"]
# [doc (alias = "PANEL2_3")]
pub type Panel2_3 = crate :: Reg < panel2_3 :: Panel2_3Spec > ; # [doc = ""]
pub mod panel2_3 { # [doc = "Register `PANEL2_3` reader"]
pub type R = crate :: R < Panel2_3Spec > ; # [doc = "Register `PANEL2_3` writer"]
pub type W = crate :: W < Panel2_3Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel2_3Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel2_3Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel2_3Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel2_3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel2_3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel2_3Spec ; impl crate :: RegisterSpec for Panel2_3Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel2_3::R`](R) reader structure"]
impl crate :: Readable for Panel2_3Spec { } # [doc = "`write(|w| ..)` method takes [`panel2_3::W`](W) writer structure"]
impl crate :: Writable for Panel2_3Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL2_3 to value 0"]
impl crate :: Resettable for Panel2_3Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL3_0 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel3_0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel3_0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel3_0`]
module"]
# [doc (alias = "PANEL3_0")]
pub type Panel3_0 = crate :: Reg < panel3_0 :: Panel3_0Spec > ; # [doc = ""]
pub mod panel3_0 { # [doc = "Register `PANEL3_0` reader"]
pub type R = crate :: R < Panel3_0Spec > ; # [doc = "Register `PANEL3_0` writer"]
pub type W = crate :: W < Panel3_0Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel3_0Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel3_0Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel3_0Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel3_0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel3_0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel3_0Spec ; impl crate :: RegisterSpec for Panel3_0Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel3_0::R`](R) reader structure"]
impl crate :: Readable for Panel3_0Spec { } # [doc = "`write(|w| ..)` method takes [`panel3_0::W`](W) writer structure"]
impl crate :: Writable for Panel3_0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL3_0 to value 0"]
impl crate :: Resettable for Panel3_0Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL3_1 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel3_1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel3_1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel3_1`]
module"]
# [doc (alias = "PANEL3_1")]
pub type Panel3_1 = crate :: Reg < panel3_1 :: Panel3_1Spec > ; # [doc = ""]
pub mod panel3_1 { # [doc = "Register `PANEL3_1` reader"]
pub type R = crate :: R < Panel3_1Spec > ; # [doc = "Register `PANEL3_1` writer"]
pub type W = crate :: W < Panel3_1Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel3_1Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel3_1Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel3_1Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel3_1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel3_1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel3_1Spec ; impl crate :: RegisterSpec for Panel3_1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel3_1::R`](R) reader structure"]
impl crate :: Readable for Panel3_1Spec { } # [doc = "`write(|w| ..)` method takes [`panel3_1::W`](W) writer structure"]
impl crate :: Writable for Panel3_1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL3_1 to value 0"]
impl crate :: Resettable for Panel3_1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL3_2 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel3_2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel3_2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel3_2`]
module"]
# [doc (alias = "PANEL3_2")]
pub type Panel3_2 = crate :: Reg < panel3_2 :: Panel3_2Spec > ; # [doc = ""]
pub mod panel3_2 { # [doc = "Register `PANEL3_2` reader"]
pub type R = crate :: R < Panel3_2Spec > ; # [doc = "Register `PANEL3_2` writer"]
pub type W = crate :: W < Panel3_2Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel3_2Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel3_2Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel3_2Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel3_2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel3_2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel3_2Spec ; impl crate :: RegisterSpec for Panel3_2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel3_2::R`](R) reader structure"]
impl crate :: Readable for Panel3_2Spec { } # [doc = "`write(|w| ..)` method takes [`panel3_2::W`](W) writer structure"]
impl crate :: Writable for Panel3_2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL3_2 to value 0"]
impl crate :: Resettable for Panel3_2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL3_3 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel3_3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel3_3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel3_3`]
module"]
# [doc (alias = "PANEL3_3")]
pub type Panel3_3 = crate :: Reg < panel3_3 :: Panel3_3Spec > ; # [doc = ""]
pub mod panel3_3 { # [doc = "Register `PANEL3_3` reader"]
pub type R = crate :: R < Panel3_3Spec > ; # [doc = "Register `PANEL3_3` writer"]
pub type W = crate :: W < Panel3_3Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel3_3Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel3_3Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel3_3Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel3_3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel3_3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel3_3Spec ; impl crate :: RegisterSpec for Panel3_3Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel3_3::R`](R) reader structure"]
impl crate :: Readable for Panel3_3Spec { } # [doc = "`write(|w| ..)` method takes [`panel3_3::W`](W) writer structure"]
impl crate :: Writable for Panel3_3Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL3_3 to value 0"]
impl crate :: Resettable for Panel3_3Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL4_0 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel4_0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel4_0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel4_0`]
module"]
# [doc (alias = "PANEL4_0")]
pub type Panel4_0 = crate :: Reg < panel4_0 :: Panel4_0Spec > ; # [doc = ""]
pub mod panel4_0 { # [doc = "Register `PANEL4_0` reader"]
pub type R = crate :: R < Panel4_0Spec > ; # [doc = "Register `PANEL4_0` writer"]
pub type W = crate :: W < Panel4_0Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel4_0Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel4_0Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel4_0Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel4_0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel4_0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel4_0Spec ; impl crate :: RegisterSpec for Panel4_0Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel4_0::R`](R) reader structure"]
impl crate :: Readable for Panel4_0Spec { } # [doc = "`write(|w| ..)` method takes [`panel4_0::W`](W) writer structure"]
impl crate :: Writable for Panel4_0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL4_0 to value 0"]
impl crate :: Resettable for Panel4_0Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL4_1 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel4_1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel4_1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel4_1`]
module"]
# [doc (alias = "PANEL4_1")]
pub type Panel4_1 = crate :: Reg < panel4_1 :: Panel4_1Spec > ; # [doc = ""]
pub mod panel4_1 { # [doc = "Register `PANEL4_1` reader"]
pub type R = crate :: R < Panel4_1Spec > ; # [doc = "Register `PANEL4_1` writer"]
pub type W = crate :: W < Panel4_1Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel4_1Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel4_1Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel4_1Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel4_1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel4_1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel4_1Spec ; impl crate :: RegisterSpec for Panel4_1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel4_1::R`](R) reader structure"]
impl crate :: Readable for Panel4_1Spec { } # [doc = "`write(|w| ..)` method takes [`panel4_1::W`](W) writer structure"]
impl crate :: Writable for Panel4_1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL4_1 to value 0"]
impl crate :: Resettable for Panel4_1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL4_2 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel4_2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel4_2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel4_2`]
module"]
# [doc (alias = "PANEL4_2")]
pub type Panel4_2 = crate :: Reg < panel4_2 :: Panel4_2Spec > ; # [doc = ""]
pub mod panel4_2 { # [doc = "Register `PANEL4_2` reader"]
pub type R = crate :: R < Panel4_2Spec > ; # [doc = "Register `PANEL4_2` writer"]
pub type W = crate :: W < Panel4_2Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel4_2Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel4_2Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel4_2Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel4_2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel4_2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel4_2Spec ; impl crate :: RegisterSpec for Panel4_2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel4_2::R`](R) reader structure"]
impl crate :: Readable for Panel4_2Spec { } # [doc = "`write(|w| ..)` method takes [`panel4_2::W`](W) writer structure"]
impl crate :: Writable for Panel4_2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL4_2 to value 0"]
impl crate :: Resettable for Panel4_2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL4_3 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel4_3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel4_3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel4_3`]
module"]
# [doc (alias = "PANEL4_3")]
pub type Panel4_3 = crate :: Reg < panel4_3 :: Panel4_3Spec > ; # [doc = ""]
pub mod panel4_3 { # [doc = "Register `PANEL4_3` reader"]
pub type R = crate :: R < Panel4_3Spec > ; # [doc = "Register `PANEL4_3` writer"]
pub type W = crate :: W < Panel4_3Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel4_3Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel4_3Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel4_3Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel4_3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel4_3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel4_3Spec ; impl crate :: RegisterSpec for Panel4_3Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel4_3::R`](R) reader structure"]
impl crate :: Readable for Panel4_3Spec { } # [doc = "`write(|w| ..)` method takes [`panel4_3::W`](W) writer structure"]
impl crate :: Writable for Panel4_3Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL4_3 to value 0"]
impl crate :: Resettable for Panel4_3Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL5_0 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel5_0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel5_0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel5_0`]
module"]
# [doc (alias = "PANEL5_0")]
pub type Panel5_0 = crate :: Reg < panel5_0 :: Panel5_0Spec > ; # [doc = ""]
pub mod panel5_0 { # [doc = "Register `PANEL5_0` reader"]
pub type R = crate :: R < Panel5_0Spec > ; # [doc = "Register `PANEL5_0` writer"]
pub type W = crate :: W < Panel5_0Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel5_0Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel5_0Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel5_0Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel5_0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel5_0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel5_0Spec ; impl crate :: RegisterSpec for Panel5_0Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel5_0::R`](R) reader structure"]
impl crate :: Readable for Panel5_0Spec { } # [doc = "`write(|w| ..)` method takes [`panel5_0::W`](W) writer structure"]
impl crate :: Writable for Panel5_0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL5_0 to value 0"]
impl crate :: Resettable for Panel5_0Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL5_1 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel5_1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel5_1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel5_1`]
module"]
# [doc (alias = "PANEL5_1")]
pub type Panel5_1 = crate :: Reg < panel5_1 :: Panel5_1Spec > ; # [doc = ""]
pub mod panel5_1 { # [doc = "Register `PANEL5_1` reader"]
pub type R = crate :: R < Panel5_1Spec > ; # [doc = "Register `PANEL5_1` writer"]
pub type W = crate :: W < Panel5_1Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel5_1Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel5_1Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel5_1Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel5_1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel5_1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel5_1Spec ; impl crate :: RegisterSpec for Panel5_1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel5_1::R`](R) reader structure"]
impl crate :: Readable for Panel5_1Spec { } # [doc = "`write(|w| ..)` method takes [`panel5_1::W`](W) writer structure"]
impl crate :: Writable for Panel5_1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL5_1 to value 0"]
impl crate :: Resettable for Panel5_1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL5_2 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel5_2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel5_2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel5_2`]
module"]
# [doc (alias = "PANEL5_2")]
pub type Panel5_2 = crate :: Reg < panel5_2 :: Panel5_2Spec > ; # [doc = ""]
pub mod panel5_2 { # [doc = "Register `PANEL5_2` reader"]
pub type R = crate :: R < Panel5_2Spec > ; # [doc = "Register `PANEL5_2` writer"]
pub type W = crate :: W < Panel5_2Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel5_2Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel5_2Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel5_2Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel5_2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel5_2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel5_2Spec ; impl crate :: RegisterSpec for Panel5_2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel5_2::R`](R) reader structure"]
impl crate :: Readable for Panel5_2Spec { } # [doc = "`write(|w| ..)` method takes [`panel5_2::W`](W) writer structure"]
impl crate :: Writable for Panel5_2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL5_2 to value 0"]
impl crate :: Resettable for Panel5_2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL5_3 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel5_3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel5_3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel5_3`]
module"]
# [doc (alias = "PANEL5_3")]
pub type Panel5_3 = crate :: Reg < panel5_3 :: Panel5_3Spec > ; # [doc = ""]
pub mod panel5_3 { # [doc = "Register `PANEL5_3` reader"]
pub type R = crate :: R < Panel5_3Spec > ; # [doc = "Register `PANEL5_3` writer"]
pub type W = crate :: W < Panel5_3Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel5_3Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel5_3Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel5_3Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel5_3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel5_3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel5_3Spec ; impl crate :: RegisterSpec for Panel5_3Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel5_3::R`](R) reader structure"]
impl crate :: Readable for Panel5_3Spec { } # [doc = "`write(|w| ..)` method takes [`panel5_3::W`](W) writer structure"]
impl crate :: Writable for Panel5_3Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL5_3 to value 0"]
impl crate :: Resettable for Panel5_3Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL6_0 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel6_0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel6_0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel6_0`]
module"]
# [doc (alias = "PANEL6_0")]
pub type Panel6_0 = crate :: Reg < panel6_0 :: Panel6_0Spec > ; # [doc = ""]
pub mod panel6_0 { # [doc = "Register `PANEL6_0` reader"]
pub type R = crate :: R < Panel6_0Spec > ; # [doc = "Register `PANEL6_0` writer"]
pub type W = crate :: W < Panel6_0Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel6_0Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel6_0Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel6_0Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel6_0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel6_0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel6_0Spec ; impl crate :: RegisterSpec for Panel6_0Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel6_0::R`](R) reader structure"]
impl crate :: Readable for Panel6_0Spec { } # [doc = "`write(|w| ..)` method takes [`panel6_0::W`](W) writer structure"]
impl crate :: Writable for Panel6_0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL6_0 to value 0"]
impl crate :: Resettable for Panel6_0Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL6_1 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel6_1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel6_1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel6_1`]
module"]
# [doc (alias = "PANEL6_1")]
pub type Panel6_1 = crate :: Reg < panel6_1 :: Panel6_1Spec > ; # [doc = ""]
pub mod panel6_1 { # [doc = "Register `PANEL6_1` reader"]
pub type R = crate :: R < Panel6_1Spec > ; # [doc = "Register `PANEL6_1` writer"]
pub type W = crate :: W < Panel6_1Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel6_1Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel6_1Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel6_1Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel6_1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel6_1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel6_1Spec ; impl crate :: RegisterSpec for Panel6_1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel6_1::R`](R) reader structure"]
impl crate :: Readable for Panel6_1Spec { } # [doc = "`write(|w| ..)` method takes [`panel6_1::W`](W) writer structure"]
impl crate :: Writable for Panel6_1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL6_1 to value 0"]
impl crate :: Resettable for Panel6_1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL6_2 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel6_2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel6_2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel6_2`]
module"]
# [doc (alias = "PANEL6_2")]
pub type Panel6_2 = crate :: Reg < panel6_2 :: Panel6_2Spec > ; # [doc = ""]
pub mod panel6_2 { # [doc = "Register `PANEL6_2` reader"]
pub type R = crate :: R < Panel6_2Spec > ; # [doc = "Register `PANEL6_2` writer"]
pub type W = crate :: W < Panel6_2Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel6_2Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel6_2Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel6_2Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel6_2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel6_2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel6_2Spec ; impl crate :: RegisterSpec for Panel6_2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel6_2::R`](R) reader structure"]
impl crate :: Readable for Panel6_2Spec { } # [doc = "`write(|w| ..)` method takes [`panel6_2::W`](W) writer structure"]
impl crate :: Writable for Panel6_2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL6_2 to value 0"]
impl crate :: Resettable for Panel6_2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL6_3 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel6_3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel6_3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel6_3`]
module"]
# [doc (alias = "PANEL6_3")]
pub type Panel6_3 = crate :: Reg < panel6_3 :: Panel6_3Spec > ; # [doc = ""]
pub mod panel6_3 { # [doc = "Register `PANEL6_3` reader"]
pub type R = crate :: R < Panel6_3Spec > ; # [doc = "Register `PANEL6_3` writer"]
pub type W = crate :: W < Panel6_3Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel6_3Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel6_3Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel6_3Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel6_3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel6_3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel6_3Spec ; impl crate :: RegisterSpec for Panel6_3Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel6_3::R`](R) reader structure"]
impl crate :: Readable for Panel6_3Spec { } # [doc = "`write(|w| ..)` method takes [`panel6_3::W`](W) writer structure"]
impl crate :: Writable for Panel6_3Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL6_3 to value 0"]
impl crate :: Resettable for Panel6_3Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL7_0 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel7_0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel7_0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel7_0`]
module"]
# [doc (alias = "PANEL7_0")]
pub type Panel7_0 = crate :: Reg < panel7_0 :: Panel7_0Spec > ; # [doc = ""]
pub mod panel7_0 { # [doc = "Register `PANEL7_0` reader"]
pub type R = crate :: R < Panel7_0Spec > ; # [doc = "Register `PANEL7_0` writer"]
pub type W = crate :: W < Panel7_0Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel7_0Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel7_0Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel7_0Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel7_0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel7_0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel7_0Spec ; impl crate :: RegisterSpec for Panel7_0Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel7_0::R`](R) reader structure"]
impl crate :: Readable for Panel7_0Spec { } # [doc = "`write(|w| ..)` method takes [`panel7_0::W`](W) writer structure"]
impl crate :: Writable for Panel7_0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL7_0 to value 0"]
impl crate :: Resettable for Panel7_0Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL7_1 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel7_1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel7_1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel7_1`]
module"]
# [doc (alias = "PANEL7_1")]
pub type Panel7_1 = crate :: Reg < panel7_1 :: Panel7_1Spec > ; # [doc = ""]
pub mod panel7_1 { # [doc = "Register `PANEL7_1` reader"]
pub type R = crate :: R < Panel7_1Spec > ; # [doc = "Register `PANEL7_1` writer"]
pub type W = crate :: W < Panel7_1Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel7_1Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel7_1Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel7_1Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel7_1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel7_1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel7_1Spec ; impl crate :: RegisterSpec for Panel7_1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel7_1::R`](R) reader structure"]
impl crate :: Readable for Panel7_1Spec { } # [doc = "`write(|w| ..)` method takes [`panel7_1::W`](W) writer structure"]
impl crate :: Writable for Panel7_1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL7_1 to value 0"]
impl crate :: Resettable for Panel7_1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL7_2 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel7_2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel7_2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel7_2`]
module"]
# [doc (alias = "PANEL7_2")]
pub type Panel7_2 = crate :: Reg < panel7_2 :: Panel7_2Spec > ; # [doc = ""]
pub mod panel7_2 { # [doc = "Register `PANEL7_2` reader"]
pub type R = crate :: R < Panel7_2Spec > ; # [doc = "Register `PANEL7_2` writer"]
pub type W = crate :: W < Panel7_2Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel7_2Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel7_2Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel7_2Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel7_2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel7_2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel7_2Spec ; impl crate :: RegisterSpec for Panel7_2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel7_2::R`](R) reader structure"]
impl crate :: Readable for Panel7_2Spec { } # [doc = "`write(|w| ..)` method takes [`panel7_2::W`](W) writer structure"]
impl crate :: Writable for Panel7_2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL7_2 to value 0"]
impl crate :: Resettable for Panel7_2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PANEL7_3 (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`panel7_3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel7_3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@panel7_3`]
module"]
# [doc (alias = "PANEL7_3")]
pub type Panel7_3 = crate :: Reg < panel7_3 :: Panel7_3Spec > ; # [doc = ""]
pub mod panel7_3 { # [doc = "Register `PANEL7_3` reader"]
pub type R = crate :: R < Panel7_3Spec > ; # [doc = "Register `PANEL7_3` writer"]
pub type W = crate :: W < Panel7_3Spec > ; # [doc = "Field `x` reader - x position in multiples of 32"]
pub type XR = crate :: FieldReader ; # [doc = "Field `x` writer - x position in multiples of 32"]
pub type XW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `y` reader - y position in multiples of 32"]
pub type YR = crate :: FieldReader ; # [doc = "Field `y` writer - y position in multiples of 32"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `rot` reader - rotation in clockwise 90°"]
pub type RotR = crate :: FieldReader ; # [doc = "Field `rot` writer - rotation in clockwise 90°"]
pub type RotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
pub fn x (& self) -> XR { XR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
pub fn rot (& self) -> RotR { RotR :: new (((self . bits >> 16) & 3) as u8) } } impl W { # [doc = "Bits 0:7 - x position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn x (& mut self) -> XW < Panel7_3Spec > { XW :: new (self , 0) } # [doc = "Bits 8:15 - y position in multiples of 32"]
# [inline (always)]
# [must_use]
pub fn y (& mut self) -> YW < Panel7_3Spec > { YW :: new (self , 8) } # [doc = "Bits 16:17 - rotation in clockwise 90°"]
# [inline (always)]
# [must_use]
pub fn rot (& mut self) -> RotW < Panel7_3Spec > { RotW :: new (self , 16) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`panel7_3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`panel7_3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Panel7_3Spec ; impl crate :: RegisterSpec for Panel7_3Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`panel7_3::R`](R) reader structure"]
impl crate :: Readable for Panel7_3Spec { } # [doc = "`write(|w| ..)` method takes [`panel7_3::W`](W) writer structure"]
impl crate :: Writable for Panel7_3Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PANEL7_3 to value 0"]
impl crate :: Resettable for Panel7_3Spec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "IDENTIFIER_MEM"]
pub struct IdentifierMem { _marker : PhantomData < * const () > } unsafe impl Send for IdentifierMem { } impl IdentifierMem { # [doc = r"Pointer to the register block"]
pub const PTR : * const identifier_mem :: RegisterBlock = 0xf000_3800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const identifier_mem :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for IdentifierMem { type Target = identifier_mem :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for IdentifierMem { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("IdentifierMem") . finish () } } # [doc = "IDENTIFIER_MEM"]
pub mod identifier_mem { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { identifier_mem : IdentifierMem , } impl RegisterBlock { # [doc = "0x00 - 8 x 51-bit memory"]
# [inline (always)]
pub const fn identifier_mem (& self) -> & IdentifierMem { & self . identifier_mem } } # [doc = "IDENTIFIER_MEM (rw) register accessor: 8 x 51-bit memory\n\nYou can [`read`](crate::Reg::read) this register and get [`identifier_mem::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`identifier_mem::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@identifier_mem`]
module"]
# [doc (alias = "IDENTIFIER_MEM")]
pub type IdentifierMem = crate :: Reg < identifier_mem :: IdentifierMemSpec > ; # [doc = "8 x 51-bit memory"]
pub mod identifier_mem { # [doc = "Register `IDENTIFIER_MEM` reader"]
pub type R = crate :: R < IdentifierMemSpec > ; # [doc = "Register `IDENTIFIER_MEM` writer"]
pub type W = crate :: W < IdentifierMemSpec > ; # [doc = "Field `identifier_mem` reader - "]
pub type IdentifierMemR = crate :: FieldReader ; # [doc = "Field `identifier_mem` writer - "]
pub type IdentifierMemW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn identifier_mem (& self) -> IdentifierMemR { IdentifierMemR :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7"]
# [inline (always)]
# [must_use]
pub fn identifier_mem (& mut self) -> IdentifierMemW < IdentifierMemSpec > { IdentifierMemW :: new (self , 0) } } # [doc = "8 x 51-bit memory\n\nYou can [`read`](crate::Reg::read) this register and get [`identifier_mem::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`identifier_mem::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IdentifierMemSpec ; impl crate :: RegisterSpec for IdentifierMemSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`identifier_mem::R`](R) reader structure"]
impl crate :: Readable for IdentifierMemSpec { } # [doc = "`write(|w| ..)` method takes [`identifier_mem::W`](W) writer structure"]
impl crate :: Writable for IdentifierMemSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets IDENTIFIER_MEM to value 0"]
impl crate :: Resettable for IdentifierMemSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "SDRAM"]
pub struct Sdram { _marker : PhantomData < * const () > } unsafe impl Send for Sdram { } impl Sdram { # [doc = r"Pointer to the register block"]
pub const PTR : * const sdram :: RegisterBlock = 0xf000_4000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sdram :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Sdram { type Target = sdram :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Sdram { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sdram") . finish () } } # [doc = "SDRAM"]
pub mod sdram { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { dfii_control : DfiiControl , dfii_pi0_command : DfiiPi0Command , dfii_pi0_command_issue : DfiiPi0CommandIssue , dfii_pi0_address : DfiiPi0Address , dfii_pi0_baddress : DfiiPi0Baddress , dfii_pi0_wrdata : DfiiPi0Wrdata , dfii_pi0_rddata : DfiiPi0Rddata , } impl RegisterBlock { # [doc = "0x00 - Control DFI signals common to all phases"]
# [inline (always)]
pub const fn dfii_control (& self) -> & DfiiControl { & self . dfii_control } # [doc = "0x04 - Control DFI signals on a single phase"]
# [inline (always)]
pub const fn dfii_pi0_command (& self) -> & DfiiPi0Command { & self . dfii_pi0_command } # [doc = "0x08 - "]
# [inline (always)]
pub const fn dfii_pi0_command_issue (& self) -> & DfiiPi0CommandIssue { & self . dfii_pi0_command_issue } # [doc = "0x0c - DFI address bus"]
# [inline (always)]
pub const fn dfii_pi0_address (& self) -> & DfiiPi0Address { & self . dfii_pi0_address } # [doc = "0x10 - DFI bank address bus"]
# [inline (always)]
pub const fn dfii_pi0_baddress (& self) -> & DfiiPi0Baddress { & self . dfii_pi0_baddress } # [doc = "0x14 - DFI write data bus"]
# [inline (always)]
pub const fn dfii_pi0_wrdata (& self) -> & DfiiPi0Wrdata { & self . dfii_pi0_wrdata } # [doc = "0x18 - DFI read data bus"]
# [inline (always)]
pub const fn dfii_pi0_rddata (& self) -> & DfiiPi0Rddata { & self . dfii_pi0_rddata } } # [doc = "DFII_CONTROL (rw) register accessor: Control DFI signals common to all phases\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_control::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dfii_control`]
module"]
# [doc (alias = "DFII_CONTROL")]
pub type DfiiControl = crate :: Reg < dfii_control :: DfiiControlSpec > ; # [doc = "Control DFI signals common to all phases"]
pub mod dfii_control { # [doc = "Register `DFII_CONTROL` reader"]
pub type R = crate :: R < DfiiControlSpec > ; # [doc = "Register `DFII_CONTROL` writer"]
pub type W = crate :: W < DfiiControlSpec > ; # [doc = "Field `sel` reader - None"]
pub type SelR = crate :: BitReader ; # [doc = "Field `sel` writer - None"]
pub type SelW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `cke` reader - DFI clock enable bus"]
pub type CkeR = crate :: BitReader ; # [doc = "Field `cke` writer - DFI clock enable bus"]
pub type CkeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `odt` reader - DFI on-die termination bus"]
pub type OdtR = crate :: BitReader ; # [doc = "Field `odt` writer - DFI on-die termination bus"]
pub type OdtW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `reset_n` reader - DFI clock reset bus"]
pub type ResetNR = crate :: BitReader ; # [doc = "Field `reset_n` writer - DFI clock reset bus"]
pub type ResetNW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - None"]
# [inline (always)]
pub fn sel (& self) -> SelR { SelR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DFI clock enable bus"]
# [inline (always)]
pub fn cke (& self) -> CkeR { CkeR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DFI on-die termination bus"]
# [inline (always)]
pub fn odt (& self) -> OdtR { OdtR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DFI clock reset bus"]
# [inline (always)]
pub fn reset_n (& self) -> ResetNR { ResetNR :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - None"]
# [inline (always)]
# [must_use]
pub fn sel (& mut self) -> SelW < DfiiControlSpec > { SelW :: new (self , 0) } # [doc = "Bit 1 - DFI clock enable bus"]
# [inline (always)]
# [must_use]
pub fn cke (& mut self) -> CkeW < DfiiControlSpec > { CkeW :: new (self , 1) } # [doc = "Bit 2 - DFI on-die termination bus"]
# [inline (always)]
# [must_use]
pub fn odt (& mut self) -> OdtW < DfiiControlSpec > { OdtW :: new (self , 2) } # [doc = "Bit 3 - DFI clock reset bus"]
# [inline (always)]
# [must_use]
pub fn reset_n (& mut self) -> ResetNW < DfiiControlSpec > { ResetNW :: new (self , 3) } } # [doc = "Control DFI signals common to all phases\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_control::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DfiiControlSpec ; impl crate :: RegisterSpec for DfiiControlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_control::R`](R) reader structure"]
impl crate :: Readable for DfiiControlSpec { } # [doc = "`write(|w| ..)` method takes [`dfii_control::W`](W) writer structure"]
impl crate :: Writable for DfiiControlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DFII_CONTROL to value 0x01"]
impl crate :: Resettable for DfiiControlSpec { const RESET_VALUE : u32 = 0x01 ; } } # [doc = "DFII_PI0_COMMAND (rw) register accessor: Control DFI signals on a single phase\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_command::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_command::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dfii_pi0_command`]
module"]
# [doc (alias = "DFII_PI0_COMMAND")]
pub type DfiiPi0Command = crate :: Reg < dfii_pi0_command :: DfiiPi0CommandSpec > ; # [doc = "Control DFI signals on a single phase"]
pub mod dfii_pi0_command { # [doc = "Register `DFII_PI0_COMMAND` reader"]
pub type R = crate :: R < DfiiPi0CommandSpec > ; # [doc = "Register `DFII_PI0_COMMAND` writer"]
pub type W = crate :: W < DfiiPi0CommandSpec > ; # [doc = "Field `cs` reader - DFI chip select bus"]
pub type CsR = crate :: BitReader ; # [doc = "Field `cs` writer - DFI chip select bus"]
pub type CsW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `we` reader - DFI write enable bus"]
pub type WeR = crate :: BitReader ; # [doc = "Field `we` writer - DFI write enable bus"]
pub type WeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `cas` reader - DFI column address strobe bus"]
pub type CasR = crate :: BitReader ; # [doc = "Field `cas` writer - DFI column address strobe bus"]
pub type CasW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `ras` reader - DFI row address strobe bus"]
pub type RasR = crate :: BitReader ; # [doc = "Field `ras` writer - DFI row address strobe bus"]
pub type RasW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `wren` reader - DFI write data enable bus"]
pub type WrenR = crate :: BitReader ; # [doc = "Field `wren` writer - DFI write data enable bus"]
pub type WrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `rden` reader - DFI read data enable bus"]
pub type RdenR = crate :: BitReader ; # [doc = "Field `rden` writer - DFI read data enable bus"]
pub type RdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `cs_top` reader - DFI chip select bus for top half only"]
pub type CsTopR = crate :: BitReader ; # [doc = "Field `cs_top` writer - DFI chip select bus for top half only"]
pub type CsTopW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `cs_bottom` reader - DFI chip select bus for bottom half only"]
pub type CsBottomR = crate :: BitReader ; # [doc = "Field `cs_bottom` writer - DFI chip select bus for bottom half only"]
pub type CsBottomW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - DFI chip select bus"]
# [inline (always)]
pub fn cs (& self) -> CsR { CsR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DFI write enable bus"]
# [inline (always)]
pub fn we (& self) -> WeR { WeR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DFI column address strobe bus"]
# [inline (always)]
pub fn cas (& self) -> CasR { CasR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DFI row address strobe bus"]
# [inline (always)]
pub fn ras (& self) -> RasR { RasR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - DFI write data enable bus"]
# [inline (always)]
pub fn wren (& self) -> WrenR { WrenR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DFI read data enable bus"]
# [inline (always)]
pub fn rden (& self) -> RdenR { RdenR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DFI chip select bus for top half only"]
# [inline (always)]
pub fn cs_top (& self) -> CsTopR { CsTopR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DFI chip select bus for bottom half only"]
# [inline (always)]
pub fn cs_bottom (& self) -> CsBottomR { CsBottomR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - DFI chip select bus"]
# [inline (always)]
# [must_use]
pub fn cs (& mut self) -> CsW < DfiiPi0CommandSpec > { CsW :: new (self , 0) } # [doc = "Bit 1 - DFI write enable bus"]
# [inline (always)]
# [must_use]
pub fn we (& mut self) -> WeW < DfiiPi0CommandSpec > { WeW :: new (self , 1) } # [doc = "Bit 2 - DFI column address strobe bus"]
# [inline (always)]
# [must_use]
pub fn cas (& mut self) -> CasW < DfiiPi0CommandSpec > { CasW :: new (self , 2) } # [doc = "Bit 3 - DFI row address strobe bus"]
# [inline (always)]
# [must_use]
pub fn ras (& mut self) -> RasW < DfiiPi0CommandSpec > { RasW :: new (self , 3) } # [doc = "Bit 4 - DFI write data enable bus"]
# [inline (always)]
# [must_use]
pub fn wren (& mut self) -> WrenW < DfiiPi0CommandSpec > { WrenW :: new (self , 4) } # [doc = "Bit 5 - DFI read data enable bus"]
# [inline (always)]
# [must_use]
pub fn rden (& mut self) -> RdenW < DfiiPi0CommandSpec > { RdenW :: new (self , 5) } # [doc = "Bit 6 - DFI chip select bus for top half only"]
# [inline (always)]
# [must_use]
pub fn cs_top (& mut self) -> CsTopW < DfiiPi0CommandSpec > { CsTopW :: new (self , 6) } # [doc = "Bit 7 - DFI chip select bus for bottom half only"]
# [inline (always)]
# [must_use]
pub fn cs_bottom (& mut self) -> CsBottomW < DfiiPi0CommandSpec > { CsBottomW :: new (self , 7) } } # [doc = "Control DFI signals on a single phase\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_command::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_command::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DfiiPi0CommandSpec ; impl crate :: RegisterSpec for DfiiPi0CommandSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_command::R`](R) reader structure"]
impl crate :: Readable for DfiiPi0CommandSpec { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_command::W`](W) writer structure"]
impl crate :: Writable for DfiiPi0CommandSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DFII_PI0_COMMAND to value 0"]
impl crate :: Resettable for DfiiPi0CommandSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DFII_PI0_COMMAND_ISSUE (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_command_issue::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_command_issue::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dfii_pi0_command_issue`]
module"]
# [doc (alias = "DFII_PI0_COMMAND_ISSUE")]
pub type DfiiPi0CommandIssue = crate :: Reg < dfii_pi0_command_issue :: DfiiPi0CommandIssueSpec > ; # [doc = ""]
pub mod dfii_pi0_command_issue { # [doc = "Register `DFII_PI0_COMMAND_ISSUE` reader"]
pub type R = crate :: R < DfiiPi0CommandIssueSpec > ; # [doc = "Register `DFII_PI0_COMMAND_ISSUE` writer"]
pub type W = crate :: W < DfiiPi0CommandIssueSpec > ; # [doc = "Field `dfii_pi0_command_issue` reader - "]
pub type DfiiPi0CommandIssueR = crate :: BitReader ; # [doc = "Field `dfii_pi0_command_issue` writer - "]
pub type DfiiPi0CommandIssueW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dfii_pi0_command_issue (& self) -> DfiiPi0CommandIssueR { DfiiPi0CommandIssueR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_command_issue (& mut self) -> DfiiPi0CommandIssueW < DfiiPi0CommandIssueSpec > { DfiiPi0CommandIssueW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_command_issue::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_command_issue::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DfiiPi0CommandIssueSpec ; impl crate :: RegisterSpec for DfiiPi0CommandIssueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_command_issue::R`](R) reader structure"]
impl crate :: Readable for DfiiPi0CommandIssueSpec { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_command_issue::W`](W) writer structure"]
impl crate :: Writable for DfiiPi0CommandIssueSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DFII_PI0_COMMAND_ISSUE to value 0"]
impl crate :: Resettable for DfiiPi0CommandIssueSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DFII_PI0_ADDRESS (rw) register accessor: DFI address bus\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_address::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_address::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dfii_pi0_address`]
module"]
# [doc (alias = "DFII_PI0_ADDRESS")]
pub type DfiiPi0Address = crate :: Reg < dfii_pi0_address :: DfiiPi0AddressSpec > ; # [doc = "DFI address bus"]
pub mod dfii_pi0_address { # [doc = "Register `DFII_PI0_ADDRESS` reader"]
pub type R = crate :: R < DfiiPi0AddressSpec > ; # [doc = "Register `DFII_PI0_ADDRESS` writer"]
pub type W = crate :: W < DfiiPi0AddressSpec > ; # [doc = "Field `dfii_pi0_address` reader - "]
pub type DfiiPi0AddressR = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi0_address` writer - "]
pub type DfiiPi0AddressW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ; impl R { # [doc = "Bits 0:10"]
# [inline (always)]
pub fn dfii_pi0_address (& self) -> DfiiPi0AddressR { DfiiPi0AddressR :: new ((self . bits & 0x07ff) as u16) } } impl W { # [doc = "Bits 0:10"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_address (& mut self) -> DfiiPi0AddressW < DfiiPi0AddressSpec > { DfiiPi0AddressW :: new (self , 0) } } # [doc = "DFI address bus\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_address::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_address::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DfiiPi0AddressSpec ; impl crate :: RegisterSpec for DfiiPi0AddressSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_address::R`](R) reader structure"]
impl crate :: Readable for DfiiPi0AddressSpec { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_address::W`](W) writer structure"]
impl crate :: Writable for DfiiPi0AddressSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DFII_PI0_ADDRESS to value 0"]
impl crate :: Resettable for DfiiPi0AddressSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DFII_PI0_BADDRESS (rw) register accessor: DFI bank address bus\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_baddress::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_baddress::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dfii_pi0_baddress`]
module"]
# [doc (alias = "DFII_PI0_BADDRESS")]
pub type DfiiPi0Baddress = crate :: Reg < dfii_pi0_baddress :: DfiiPi0BaddressSpec > ; # [doc = "DFI bank address bus"]
pub mod dfii_pi0_baddress { # [doc = "Register `DFII_PI0_BADDRESS` reader"]
pub type R = crate :: R < DfiiPi0BaddressSpec > ; # [doc = "Register `DFII_PI0_BADDRESS` writer"]
pub type W = crate :: W < DfiiPi0BaddressSpec > ; # [doc = "Field `dfii_pi0_baddress` reader - "]
pub type DfiiPi0BaddressR = crate :: BitReader ; # [doc = "Field `dfii_pi0_baddress` writer - "]
pub type DfiiPi0BaddressW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dfii_pi0_baddress (& self) -> DfiiPi0BaddressR { DfiiPi0BaddressR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_baddress (& mut self) -> DfiiPi0BaddressW < DfiiPi0BaddressSpec > { DfiiPi0BaddressW :: new (self , 0) } } # [doc = "DFI bank address bus\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_baddress::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_baddress::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DfiiPi0BaddressSpec ; impl crate :: RegisterSpec for DfiiPi0BaddressSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_baddress::R`](R) reader structure"]
impl crate :: Readable for DfiiPi0BaddressSpec { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_baddress::W`](W) writer structure"]
impl crate :: Writable for DfiiPi0BaddressSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DFII_PI0_BADDRESS to value 0"]
impl crate :: Resettable for DfiiPi0BaddressSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DFII_PI0_WRDATA (rw) register accessor: DFI write data bus\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_wrdata::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_wrdata::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dfii_pi0_wrdata`]
module"]
# [doc (alias = "DFII_PI0_WRDATA")]
pub type DfiiPi0Wrdata = crate :: Reg < dfii_pi0_wrdata :: DfiiPi0WrdataSpec > ; # [doc = "DFI write data bus"]
pub mod dfii_pi0_wrdata { # [doc = "Register `DFII_PI0_WRDATA` reader"]
pub type R = crate :: R < DfiiPi0WrdataSpec > ; # [doc = "Register `DFII_PI0_WRDATA` writer"]
pub type W = crate :: W < DfiiPi0WrdataSpec > ; # [doc = "Field `dfii_pi0_wrdata` reader - "]
pub type DfiiPi0WrdataR = crate :: FieldReader < u32 > ; # [doc = "Field `dfii_pi0_wrdata` writer - "]
pub type DfiiPi0WrdataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn dfii_pi0_wrdata (& self) -> DfiiPi0WrdataR { DfiiPi0WrdataR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_wrdata (& mut self) -> DfiiPi0WrdataW < DfiiPi0WrdataSpec > { DfiiPi0WrdataW :: new (self , 0) } } # [doc = "DFI write data bus\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_wrdata::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_wrdata::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DfiiPi0WrdataSpec ; impl crate :: RegisterSpec for DfiiPi0WrdataSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_wrdata::R`](R) reader structure"]
impl crate :: Readable for DfiiPi0WrdataSpec { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_wrdata::W`](W) writer structure"]
impl crate :: Writable for DfiiPi0WrdataSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DFII_PI0_WRDATA to value 0"]
impl crate :: Resettable for DfiiPi0WrdataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DFII_PI0_RDDATA (rw) register accessor: DFI read data bus\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_rddata::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_rddata::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dfii_pi0_rddata`]
module"]
# [doc (alias = "DFII_PI0_RDDATA")]
pub type DfiiPi0Rddata = crate :: Reg < dfii_pi0_rddata :: DfiiPi0RddataSpec > ; # [doc = "DFI read data bus"]
pub mod dfii_pi0_rddata { # [doc = "Register `DFII_PI0_RDDATA` reader"]
pub type R = crate :: R < DfiiPi0RddataSpec > ; # [doc = "Register `DFII_PI0_RDDATA` writer"]
pub type W = crate :: W < DfiiPi0RddataSpec > ; # [doc = "Field `dfii_pi0_rddata` reader - "]
pub type DfiiPi0RddataR = crate :: FieldReader < u32 > ; # [doc = "Field `dfii_pi0_rddata` writer - "]
pub type DfiiPi0RddataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn dfii_pi0_rddata (& self) -> DfiiPi0RddataR { DfiiPi0RddataR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_rddata (& mut self) -> DfiiPi0RddataW < DfiiPi0RddataSpec > { DfiiPi0RddataW :: new (self , 0) } } # [doc = "DFI read data bus\n\nYou can [`read`](crate::Reg::read) this register and get [`dfii_pi0_rddata::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dfii_pi0_rddata::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DfiiPi0RddataSpec ; impl crate :: RegisterSpec for DfiiPi0RddataSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_rddata::R`](R) reader structure"]
impl crate :: Readable for DfiiPi0RddataSpec { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_rddata::W`](W) writer structure"]
impl crate :: Writable for DfiiPi0RddataSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DFII_PI0_RDDATA to value 0"]
impl crate :: Resettable for DfiiPi0RddataSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "TIMER0"]
pub struct Timer0 { _marker : PhantomData < * const () > } unsafe impl Send for Timer0 { } impl Timer0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer0 :: RegisterBlock = 0xf000_4800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Timer0 { type Target = timer0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Timer0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer0") . finish () } } # [doc = "TIMER0"]
pub mod timer0 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { load : Load , reload : Reload , en : En , update_value : UpdateValue , value : Value , ev_status : EvStatus , ev_pending : EvPending , ev_enable : EvEnable , } impl RegisterBlock { # [doc = "0x00 - Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles."]
# [inline (always)]
pub const fn load (& self) -> & Load { & self . load } # [doc = "0x04 - Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles."]
# [inline (always)]
pub const fn reload (& self) -> & Reload { & self . reload } # [doc = "0x08 - Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer."]
# [inline (always)]
pub const fn en (& self) -> & En { & self . en } # [doc = "0x0c - Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register."]
# [inline (always)]
pub const fn update_value (& self) -> & UpdateValue { & self . update_value } # [doc = "0x10 - Latched countdown value. This value is updated by writing to ``update_value``."]
# [inline (always)]
pub const fn value (& self) -> & Value { & self . value } # [doc = "0x14 - This register contains the current raw level of the zero event trigger. Writes to this register have no effect."]
# [inline (always)]
pub const fn ev_status (& self) -> & EvStatus { & self . ev_status } # [doc = "0x18 - When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
# [inline (always)]
pub const fn ev_pending (& self) -> & EvPending { & self . ev_pending } # [doc = "0x1c - This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events."]
# [inline (always)]
pub const fn ev_enable (& self) -> & EvEnable { & self . ev_enable } } # [doc = "LOAD (rw) register accessor: Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles.\n\nYou can [`read`](crate::Reg::read) this register and get [`load::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`load::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@load`]
module"]
# [doc (alias = "LOAD")]
pub type Load = crate :: Reg < load :: LoadSpec > ; # [doc = "Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles."]
pub mod load { # [doc = "Register `LOAD` reader"]
pub type R = crate :: R < LoadSpec > ; # [doc = "Register `LOAD` writer"]
pub type W = crate :: W < LoadSpec > ; # [doc = "Field `load` reader - "]
pub type LoadR = crate :: FieldReader < u32 > ; # [doc = "Field `load` writer - "]
pub type LoadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn load (& self) -> LoadR { LoadR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn load (& mut self) -> LoadW < LoadSpec > { LoadW :: new (self , 0) } } # [doc = "Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles.\n\nYou can [`read`](crate::Reg::read) this register and get [`load::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`load::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct LoadSpec ; impl crate :: RegisterSpec for LoadSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`load::R`](R) reader structure"]
impl crate :: Readable for LoadSpec { } # [doc = "`write(|w| ..)` method takes [`load::W`](W) writer structure"]
impl crate :: Writable for LoadSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets LOAD to value 0"]
impl crate :: Resettable for LoadSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RELOAD (rw) register accessor: Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles.\n\nYou can [`read`](crate::Reg::read) this register and get [`reload::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reload::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reload`]
module"]
# [doc (alias = "RELOAD")]
pub type Reload = crate :: Reg < reload :: ReloadSpec > ; # [doc = "Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles."]
pub mod reload { # [doc = "Register `RELOAD` reader"]
pub type R = crate :: R < ReloadSpec > ; # [doc = "Register `RELOAD` writer"]
pub type W = crate :: W < ReloadSpec > ; # [doc = "Field `reload` reader - "]
pub type ReloadR = crate :: FieldReader < u32 > ; # [doc = "Field `reload` writer - "]
pub type ReloadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn reload (& self) -> ReloadR { ReloadR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn reload (& mut self) -> ReloadW < ReloadSpec > { ReloadW :: new (self , 0) } } # [doc = "Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles.\n\nYou can [`read`](crate::Reg::read) this register and get [`reload::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reload::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ReloadSpec ; impl crate :: RegisterSpec for ReloadSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`reload::R`](R) reader structure"]
impl crate :: Readable for ReloadSpec { } # [doc = "`write(|w| ..)` method takes [`reload::W`](W) writer structure"]
impl crate :: Writable for ReloadSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RELOAD to value 0"]
impl crate :: Resettable for ReloadSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EN (rw) register accessor: Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer.\n\nYou can [`read`](crate::Reg::read) this register and get [`en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@en`]
module"]
# [doc (alias = "EN")]
pub type En = crate :: Reg < en :: EnSpec > ; # [doc = "Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer."]
pub mod en { # [doc = "Register `EN` reader"]
pub type R = crate :: R < EnSpec > ; # [doc = "Register `EN` writer"]
pub type W = crate :: W < EnSpec > ; # [doc = "Field `en` reader - "]
pub type EnR = crate :: BitReader ; # [doc = "Field `en` writer - "]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn en (& mut self) -> EnW < EnSpec > { EnW :: new (self , 0) } } # [doc = "Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer.\n\nYou can [`read`](crate::Reg::read) this register and get [`en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EnSpec ; impl crate :: RegisterSpec for EnSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`en::R`](R) reader structure"]
impl crate :: Readable for EnSpec { } # [doc = "`write(|w| ..)` method takes [`en::W`](W) writer structure"]
impl crate :: Writable for EnSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EN to value 0"]
impl crate :: Resettable for EnSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "UPDATE_VALUE (rw) register accessor: Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register.\n\nYou can [`read`](crate::Reg::read) this register and get [`update_value::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`update_value::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@update_value`]
module"]
# [doc (alias = "UPDATE_VALUE")]
pub type UpdateValue = crate :: Reg < update_value :: UpdateValueSpec > ; # [doc = "Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register."]
pub mod update_value { # [doc = "Register `UPDATE_VALUE` reader"]
pub type R = crate :: R < UpdateValueSpec > ; # [doc = "Register `UPDATE_VALUE` writer"]
pub type W = crate :: W < UpdateValueSpec > ; # [doc = "Field `update_value` reader - "]
pub type UpdateValueR = crate :: BitReader ; # [doc = "Field `update_value` writer - "]
pub type UpdateValueW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn update_value (& self) -> UpdateValueR { UpdateValueR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn update_value (& mut self) -> UpdateValueW < UpdateValueSpec > { UpdateValueW :: new (self , 0) } } # [doc = "Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register.\n\nYou can [`read`](crate::Reg::read) this register and get [`update_value::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`update_value::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct UpdateValueSpec ; impl crate :: RegisterSpec for UpdateValueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`update_value::R`](R) reader structure"]
impl crate :: Readable for UpdateValueSpec { } # [doc = "`write(|w| ..)` method takes [`update_value::W`](W) writer structure"]
impl crate :: Writable for UpdateValueSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets UPDATE_VALUE to value 0"]
impl crate :: Resettable for UpdateValueSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "VALUE (rw) register accessor: Latched countdown value. This value is updated by writing to ``update_value``.\n\nYou can [`read`](crate::Reg::read) this register and get [`value::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`value::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@value`]
module"]
# [doc (alias = "VALUE")]
pub type Value = crate :: Reg < value :: ValueSpec > ; # [doc = "Latched countdown value. This value is updated by writing to ``update_value``."]
pub mod value { # [doc = "Register `VALUE` reader"]
pub type R = crate :: R < ValueSpec > ; # [doc = "Register `VALUE` writer"]
pub type W = crate :: W < ValueSpec > ; # [doc = "Field `value` reader - "]
pub type ValueR = crate :: FieldReader < u32 > ; # [doc = "Field `value` writer - "]
pub type ValueW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn value (& self) -> ValueR { ValueR :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn value (& mut self) -> ValueW < ValueSpec > { ValueW :: new (self , 0) } } # [doc = "Latched countdown value. This value is updated by writing to ``update_value``.\n\nYou can [`read`](crate::Reg::read) this register and get [`value::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`value::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ValueSpec ; impl crate :: RegisterSpec for ValueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`value::R`](R) reader structure"]
impl crate :: Readable for ValueSpec { } # [doc = "`write(|w| ..)` method takes [`value::W`](W) writer structure"]
impl crate :: Writable for ValueSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets VALUE to value 0"]
impl crate :: Resettable for ValueSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EV_STATUS (rw) register accessor: This register contains the current raw level of the zero event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_status::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_status::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_status`]
module"]
# [doc (alias = "EV_STATUS")]
pub type EvStatus = crate :: Reg < ev_status :: EvStatusSpec > ; # [doc = "This register contains the current raw level of the zero event trigger. Writes to this register have no effect."]
pub mod ev_status { # [doc = "Register `EV_STATUS` reader"]
pub type R = crate :: R < EvStatusSpec > ; # [doc = "Register `EV_STATUS` writer"]
pub type W = crate :: W < EvStatusSpec > ; # [doc = "Field `zero` reader - Level of the ``zero`` event"]
pub type ZeroR = crate :: BitReader ; # [doc = "Field `zero` writer - Level of the ``zero`` event"]
pub type ZeroW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Level of the ``zero`` event"]
# [inline (always)]
pub fn zero (& self) -> ZeroR { ZeroR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Level of the ``zero`` event"]
# [inline (always)]
# [must_use]
pub fn zero (& mut self) -> ZeroW < EvStatusSpec > { ZeroW :: new (self , 0) } } # [doc = "This register contains the current raw level of the zero event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_status::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_status::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EvStatusSpec ; impl crate :: RegisterSpec for EvStatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_status::R`](R) reader structure"]
impl crate :: Readable for EvStatusSpec { } # [doc = "`write(|w| ..)` method takes [`ev_status::W`](W) writer structure"]
impl crate :: Writable for EvStatusSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EV_STATUS to value 0"]
impl crate :: Resettable for EvStatusSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EV_PENDING (rw) register accessor: When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_pending::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_pending::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_pending`]
module"]
# [doc (alias = "EV_PENDING")]
pub type EvPending = crate :: Reg < ev_pending :: EvPendingSpec > ; # [doc = "When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub mod ev_pending { # [doc = "Register `EV_PENDING` reader"]
pub type R = crate :: R < EvPendingSpec > ; # [doc = "Register `EV_PENDING` writer"]
pub type W = crate :: W < EvPendingSpec > ; # [doc = "Field `zero` reader - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
pub type ZeroR = crate :: BitReader ; # [doc = "Field `zero` writer - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
pub type ZeroW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
pub fn zero (& self) -> ZeroR { ZeroR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
# [must_use]
pub fn zero (& mut self) -> ZeroW < EvPendingSpec > { ZeroW :: new (self , 0) } } # [doc = "When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_pending::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_pending::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EvPendingSpec ; impl crate :: RegisterSpec for EvPendingSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_pending::R`](R) reader structure"]
impl crate :: Readable for EvPendingSpec { } # [doc = "`write(|w| ..)` method takes [`ev_pending::W`](W) writer structure"]
impl crate :: Writable for EvPendingSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EV_PENDING to value 0"]
impl crate :: Resettable for EvPendingSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EV_ENABLE (rw) register accessor: This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_enable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_enable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_enable`]
module"]
# [doc (alias = "EV_ENABLE")]
pub type EvEnable = crate :: Reg < ev_enable :: EvEnableSpec > ; # [doc = "This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events."]
pub mod ev_enable { # [doc = "Register `EV_ENABLE` reader"]
pub type R = crate :: R < EvEnableSpec > ; # [doc = "Register `EV_ENABLE` writer"]
pub type W = crate :: W < EvEnableSpec > ; # [doc = "Field `zero` reader - Write a ``1`` to enable the ``zero`` Event"]
pub type ZeroR = crate :: BitReader ; # [doc = "Field `zero` writer - Write a ``1`` to enable the ``zero`` Event"]
pub type ZeroW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Write a ``1`` to enable the ``zero`` Event"]
# [inline (always)]
pub fn zero (& self) -> ZeroR { ZeroR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Write a ``1`` to enable the ``zero`` Event"]
# [inline (always)]
# [must_use]
pub fn zero (& mut self) -> ZeroW < EvEnableSpec > { ZeroW :: new (self , 0) } } # [doc = "This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_enable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_enable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EvEnableSpec ; impl crate :: RegisterSpec for EvEnableSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_enable::R`](R) reader structure"]
impl crate :: Readable for EvEnableSpec { } # [doc = "`write(|w| ..)` method takes [`ev_enable::W`](W) writer structure"]
impl crate :: Writable for EvEnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EV_ENABLE to value 0"]
impl crate :: Resettable for EvEnableSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "UART"]
pub struct Uart { _marker : PhantomData < * const () > } unsafe impl Send for Uart { } impl Uart { # [doc = r"Pointer to the register block"]
pub const PTR : * const uart :: RegisterBlock = 0xf000_5000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const uart :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Uart { type Target = uart :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Uart { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart") . finish () } } # [doc = "UART"]
pub mod uart { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { rxtx : Rxtx , txfull : Txfull , rxempty : Rxempty , ev_status : EvStatus , ev_pending : EvPending , ev_enable : EvEnable , txempty : Txempty , rxfull : Rxfull , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn rxtx (& self) -> & Rxtx { & self . rxtx } # [doc = "0x04 - TX FIFO Full."]
# [inline (always)]
pub const fn txfull (& self) -> & Txfull { & self . txfull } # [doc = "0x08 - RX FIFO Empty."]
# [inline (always)]
pub const fn rxempty (& self) -> & Rxempty { & self . rxempty } # [doc = "0x0c - This register contains the current raw level of the rx event trigger. Writes to this register have no effect."]
# [inline (always)]
pub const fn ev_status (& self) -> & EvStatus { & self . ev_status } # [doc = "0x10 - When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
# [inline (always)]
pub const fn ev_pending (& self) -> & EvPending { & self . ev_pending } # [doc = "0x14 - This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events."]
# [inline (always)]
pub const fn ev_enable (& self) -> & EvEnable { & self . ev_enable } # [doc = "0x18 - TX FIFO Empty."]
# [inline (always)]
pub const fn txempty (& self) -> & Txempty { & self . txempty } # [doc = "0x1c - RX FIFO Full."]
# [inline (always)]
pub const fn rxfull (& self) -> & Rxfull { & self . rxfull } } # [doc = "RXTX (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`rxtx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxtx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxtx`]
module"]
# [doc (alias = "RXTX")]
pub type Rxtx = crate :: Reg < rxtx :: RxtxSpec > ; # [doc = ""]
pub mod rxtx { # [doc = "Register `RXTX` reader"]
pub type R = crate :: R < RxtxSpec > ; # [doc = "Register `RXTX` writer"]
pub type W = crate :: W < RxtxSpec > ; # [doc = "Field `rxtx` reader - "]
pub type RxtxR = crate :: FieldReader ; # [doc = "Field `rxtx` writer - "]
pub type RxtxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn rxtx (& self) -> RxtxR { RxtxR :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7"]
# [inline (always)]
# [must_use]
pub fn rxtx (& mut self) -> RxtxW < RxtxSpec > { RxtxW :: new (self , 0) } } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`rxtx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxtx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxtxSpec ; impl crate :: RegisterSpec for RxtxSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rxtx::R`](R) reader structure"]
impl crate :: Readable for RxtxSpec { } # [doc = "`write(|w| ..)` method takes [`rxtx::W`](W) writer structure"]
impl crate :: Writable for RxtxSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RXTX to value 0"]
impl crate :: Resettable for RxtxSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TXFULL (rw) register accessor: TX FIFO Full.\n\nYou can [`read`](crate::Reg::read) this register and get [`txfull::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txfull::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txfull`]
module"]
# [doc (alias = "TXFULL")]
pub type Txfull = crate :: Reg < txfull :: TxfullSpec > ; # [doc = "TX FIFO Full."]
pub mod txfull { # [doc = "Register `TXFULL` reader"]
pub type R = crate :: R < TxfullSpec > ; # [doc = "Register `TXFULL` writer"]
pub type W = crate :: W < TxfullSpec > ; # [doc = "Field `txfull` reader - "]
pub type TxfullR = crate :: BitReader ; # [doc = "Field `txfull` writer - "]
pub type TxfullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn txfull (& self) -> TxfullR { TxfullR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn txfull (& mut self) -> TxfullW < TxfullSpec > { TxfullW :: new (self , 0) } } # [doc = "TX FIFO Full.\n\nYou can [`read`](crate::Reg::read) this register and get [`txfull::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txfull::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxfullSpec ; impl crate :: RegisterSpec for TxfullSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`txfull::R`](R) reader structure"]
impl crate :: Readable for TxfullSpec { } # [doc = "`write(|w| ..)` method takes [`txfull::W`](W) writer structure"]
impl crate :: Writable for TxfullSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TXFULL to value 0"]
impl crate :: Resettable for TxfullSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RXEMPTY (rw) register accessor: RX FIFO Empty.\n\nYou can [`read`](crate::Reg::read) this register and get [`rxempty::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxempty::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxempty`]
module"]
# [doc (alias = "RXEMPTY")]
pub type Rxempty = crate :: Reg < rxempty :: RxemptySpec > ; # [doc = "RX FIFO Empty."]
pub mod rxempty { # [doc = "Register `RXEMPTY` reader"]
pub type R = crate :: R < RxemptySpec > ; # [doc = "Register `RXEMPTY` writer"]
pub type W = crate :: W < RxemptySpec > ; # [doc = "Field `rxempty` reader - "]
pub type RxemptyR = crate :: BitReader ; # [doc = "Field `rxempty` writer - "]
pub type RxemptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn rxempty (& self) -> RxemptyR { RxemptyR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn rxempty (& mut self) -> RxemptyW < RxemptySpec > { RxemptyW :: new (self , 0) } } # [doc = "RX FIFO Empty.\n\nYou can [`read`](crate::Reg::read) this register and get [`rxempty::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxempty::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxemptySpec ; impl crate :: RegisterSpec for RxemptySpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rxempty::R`](R) reader structure"]
impl crate :: Readable for RxemptySpec { } # [doc = "`write(|w| ..)` method takes [`rxempty::W`](W) writer structure"]
impl crate :: Writable for RxemptySpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RXEMPTY to value 0"]
impl crate :: Resettable for RxemptySpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EV_STATUS (rw) register accessor: This register contains the current raw level of the rx event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_status::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_status::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_status`]
module"]
# [doc (alias = "EV_STATUS")]
pub type EvStatus = crate :: Reg < ev_status :: EvStatusSpec > ; # [doc = "This register contains the current raw level of the rx event trigger. Writes to this register have no effect."]
pub mod ev_status { # [doc = "Register `EV_STATUS` reader"]
pub type R = crate :: R < EvStatusSpec > ; # [doc = "Register `EV_STATUS` writer"]
pub type W = crate :: W < EvStatusSpec > ; # [doc = "Field `tx` reader - Level of the ``tx`` event"]
pub type TxR = crate :: BitReader ; # [doc = "Field `tx` writer - Level of the ``tx`` event"]
pub type TxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `rx` reader - Level of the ``rx`` event"]
pub type RxR = crate :: BitReader ; # [doc = "Field `rx` writer - Level of the ``rx`` event"]
pub type RxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Level of the ``tx`` event"]
# [inline (always)]
pub fn tx (& self) -> TxR { TxR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Level of the ``rx`` event"]
# [inline (always)]
pub fn rx (& self) -> RxR { RxR :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Level of the ``tx`` event"]
# [inline (always)]
# [must_use]
pub fn tx (& mut self) -> TxW < EvStatusSpec > { TxW :: new (self , 0) } # [doc = "Bit 1 - Level of the ``rx`` event"]
# [inline (always)]
# [must_use]
pub fn rx (& mut self) -> RxW < EvStatusSpec > { RxW :: new (self , 1) } } # [doc = "This register contains the current raw level of the rx event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_status::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_status::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EvStatusSpec ; impl crate :: RegisterSpec for EvStatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_status::R`](R) reader structure"]
impl crate :: Readable for EvStatusSpec { } # [doc = "`write(|w| ..)` method takes [`ev_status::W`](W) writer structure"]
impl crate :: Writable for EvStatusSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EV_STATUS to value 0"]
impl crate :: Resettable for EvStatusSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EV_PENDING (rw) register accessor: When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_pending::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_pending::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_pending`]
module"]
# [doc (alias = "EV_PENDING")]
pub type EvPending = crate :: Reg < ev_pending :: EvPendingSpec > ; # [doc = "When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub mod ev_pending { # [doc = "Register `EV_PENDING` reader"]
pub type R = crate :: R < EvPendingSpec > ; # [doc = "Register `EV_PENDING` writer"]
pub type W = crate :: W < EvPendingSpec > ; # [doc = "Field `tx` reader - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
pub type TxR = crate :: BitReader ; # [doc = "Field `tx` writer - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
pub type TxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `rx` reader - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
pub type RxR = crate :: BitReader ; # [doc = "Field `rx` writer - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
pub type RxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
pub fn tx (& self) -> TxR { TxR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
pub fn rx (& self) -> RxR { RxR :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
# [must_use]
pub fn tx (& mut self) -> TxW < EvPendingSpec > { TxW :: new (self , 0) } # [doc = "Bit 1 - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
# [must_use]
pub fn rx (& mut self) -> RxW < EvPendingSpec > { RxW :: new (self , 1) } } # [doc = "When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_pending::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_pending::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EvPendingSpec ; impl crate :: RegisterSpec for EvPendingSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_pending::R`](R) reader structure"]
impl crate :: Readable for EvPendingSpec { } # [doc = "`write(|w| ..)` method takes [`ev_pending::W`](W) writer structure"]
impl crate :: Writable for EvPendingSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EV_PENDING to value 0"]
impl crate :: Resettable for EvPendingSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EV_ENABLE (rw) register accessor: This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_enable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_enable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_enable`]
module"]
# [doc (alias = "EV_ENABLE")]
pub type EvEnable = crate :: Reg < ev_enable :: EvEnableSpec > ; # [doc = "This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events."]
pub mod ev_enable { # [doc = "Register `EV_ENABLE` reader"]
pub type R = crate :: R < EvEnableSpec > ; # [doc = "Register `EV_ENABLE` writer"]
pub type W = crate :: W < EvEnableSpec > ; # [doc = "Field `tx` reader - Write a ``1`` to enable the ``tx`` Event"]
pub type TxR = crate :: BitReader ; # [doc = "Field `tx` writer - Write a ``1`` to enable the ``tx`` Event"]
pub type TxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `rx` reader - Write a ``1`` to enable the ``rx`` Event"]
pub type RxR = crate :: BitReader ; # [doc = "Field `rx` writer - Write a ``1`` to enable the ``rx`` Event"]
pub type RxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Write a ``1`` to enable the ``tx`` Event"]
# [inline (always)]
pub fn tx (& self) -> TxR { TxR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Write a ``1`` to enable the ``rx`` Event"]
# [inline (always)]
pub fn rx (& self) -> RxR { RxR :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Write a ``1`` to enable the ``tx`` Event"]
# [inline (always)]
# [must_use]
pub fn tx (& mut self) -> TxW < EvEnableSpec > { TxW :: new (self , 0) } # [doc = "Bit 1 - Write a ``1`` to enable the ``rx`` Event"]
# [inline (always)]
# [must_use]
pub fn rx (& mut self) -> RxW < EvEnableSpec > { RxW :: new (self , 1) } } # [doc = "This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::Reg::read) this register and get [`ev_enable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ev_enable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EvEnableSpec ; impl crate :: RegisterSpec for EvEnableSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_enable::R`](R) reader structure"]
impl crate :: Readable for EvEnableSpec { } # [doc = "`write(|w| ..)` method takes [`ev_enable::W`](W) writer structure"]
impl crate :: Writable for EvEnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EV_ENABLE to value 0"]
impl crate :: Resettable for EvEnableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TXEMPTY (rw) register accessor: TX FIFO Empty.\n\nYou can [`read`](crate::Reg::read) this register and get [`txempty::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txempty::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txempty`]
module"]
# [doc (alias = "TXEMPTY")]
pub type Txempty = crate :: Reg < txempty :: TxemptySpec > ; # [doc = "TX FIFO Empty."]
pub mod txempty { # [doc = "Register `TXEMPTY` reader"]
pub type R = crate :: R < TxemptySpec > ; # [doc = "Register `TXEMPTY` writer"]
pub type W = crate :: W < TxemptySpec > ; # [doc = "Field `txempty` reader - "]
pub type TxemptyR = crate :: BitReader ; # [doc = "Field `txempty` writer - "]
pub type TxemptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn txempty (& self) -> TxemptyR { TxemptyR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn txempty (& mut self) -> TxemptyW < TxemptySpec > { TxemptyW :: new (self , 0) } } # [doc = "TX FIFO Empty.\n\nYou can [`read`](crate::Reg::read) this register and get [`txempty::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txempty::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxemptySpec ; impl crate :: RegisterSpec for TxemptySpec { type Ux = u32 ; } # [doc = "`read()` method returns [`txempty::R`](R) reader structure"]
impl crate :: Readable for TxemptySpec { } # [doc = "`write(|w| ..)` method takes [`txempty::W`](W) writer structure"]
impl crate :: Writable for TxemptySpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TXEMPTY to value 0"]
impl crate :: Resettable for TxemptySpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RXFULL (rw) register accessor: RX FIFO Full.\n\nYou can [`read`](crate::Reg::read) this register and get [`rxfull::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxfull::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxfull`]
module"]
# [doc (alias = "RXFULL")]
pub type Rxfull = crate :: Reg < rxfull :: RxfullSpec > ; # [doc = "RX FIFO Full."]
pub mod rxfull { # [doc = "Register `RXFULL` reader"]
pub type R = crate :: R < RxfullSpec > ; # [doc = "Register `RXFULL` writer"]
pub type W = crate :: W < RxfullSpec > ; # [doc = "Field `rxfull` reader - "]
pub type RxfullR = crate :: BitReader ; # [doc = "Field `rxfull` writer - "]
pub type RxfullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn rxfull (& self) -> RxfullR { RxfullR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn rxfull (& mut self) -> RxfullW < RxfullSpec > { RxfullW :: new (self , 0) } } # [doc = "RX FIFO Full.\n\nYou can [`read`](crate::Reg::read) this register and get [`rxfull::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxfull::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxfullSpec ; impl crate :: RegisterSpec for RxfullSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rxfull::R`](R) reader structure"]
impl crate :: Readable for RxfullSpec { } # [doc = "`write(|w| ..)` method takes [`rxfull::W`](W) writer structure"]
impl crate :: Writable for RxfullSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RXFULL to value 0"]
impl crate :: Resettable for RxfullSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "ETHMEM"]
pub struct Ethmem { _marker : PhantomData < * const () > } unsafe impl Send for Ethmem { } impl Ethmem { # [doc = r"Pointer to the register block"]
pub const PTR : * const ethmem :: RegisterBlock = 0x8020_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ethmem :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Ethmem { type Target = ethmem :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Ethmem { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ethmem") . finish () } } # [doc = "ETHMEM"]
pub mod ethmem { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { rx_buffer_0 : [RxBuffer0 ; 2048]
, rx_buffer_1 : [RxBuffer1 ; 2048]
, tx_buffer_0 : [TxBuffer0 ; 2048]
, tx_buffer_1 : [TxBuffer1 ; 2048]
, } impl RegisterBlock { # [doc = "0x00..0x800 - rx buffers"]
# [inline (always)]
pub const fn rx_buffer_0 (& self , n : usize) -> & RxBuffer0 { & self . rx_buffer_0 [n]
} # [doc = "Iterator for array of:"]
# [doc = "0x00..0x800 - rx buffers"]
# [inline (always)]
pub fn rx_buffer_0_iter (& self) -> impl Iterator < Item = & RxBuffer0 > { self . rx_buffer_0 . iter () } # [doc = "0x800..0x1000 - rx buffers"]
# [inline (always)]
pub const fn rx_buffer_1 (& self , n : usize) -> & RxBuffer1 { & self . rx_buffer_1 [n]
} # [doc = "Iterator for array of:"]
# [doc = "0x800..0x1000 - rx buffers"]
# [inline (always)]
pub fn rx_buffer_1_iter (& self) -> impl Iterator < Item = & RxBuffer1 > { self . rx_buffer_1 . iter () } # [doc = "0x1000..0x1800 - tx buffers"]
# [inline (always)]
pub const fn tx_buffer_0 (& self , n : usize) -> & TxBuffer0 { & self . tx_buffer_0 [n]
} # [doc = "Iterator for array of:"]
# [doc = "0x1000..0x1800 - tx buffers"]
# [inline (always)]
pub fn tx_buffer_0_iter (& self) -> impl Iterator < Item = & TxBuffer0 > { self . tx_buffer_0 . iter () } # [doc = "0x1800..0x2000 - tx buffers"]
# [inline (always)]
pub const fn tx_buffer_1 (& self , n : usize) -> & TxBuffer1 { & self . tx_buffer_1 [n]
} # [doc = "Iterator for array of:"]
# [doc = "0x1800..0x2000 - tx buffers"]
# [inline (always)]
pub fn tx_buffer_1_iter (& self) -> impl Iterator < Item = & TxBuffer1 > { self . tx_buffer_1 . iter () } } # [doc = "RX_BUFFER_0 (r) register accessor: rx buffers\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_buffer_0::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_buffer_0`]
module"]
# [doc (alias = "RX_BUFFER_0")]
pub type RxBuffer0 = crate :: Reg < rx_buffer_0 :: RxBuffer0Spec > ; # [doc = "rx buffers"]
pub mod rx_buffer_0 { # [doc = "Register `RX_BUFFER_0[%s]` reader"]
pub type R = crate :: R < RxBuffer0Spec > ; # [doc = "Field `rx_buffer_0` reader - "]
pub type RxBuffer0R = crate :: FieldReader ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn rx_buffer_0 (& self) -> RxBuffer0R { RxBuffer0R :: new (self . bits) } } # [doc = "rx buffers\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_buffer_0::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxBuffer0Spec ; impl crate :: RegisterSpec for RxBuffer0Spec { type Ux = u8 ; } # [doc = "`read()` method returns [`rx_buffer_0::R`](R) reader structure"]
impl crate :: Readable for RxBuffer0Spec { } # [doc = "`reset()` method sets RX_BUFFER_0[%s]
to value 0"]
impl crate :: Resettable for RxBuffer0Spec { const RESET_VALUE : u8 = 0 ; } } # [doc = "RX_BUFFER_1 (r) register accessor: rx buffers\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_buffer_1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_buffer_1`]
module"]
# [doc (alias = "RX_BUFFER_1")]
pub type RxBuffer1 = crate :: Reg < rx_buffer_1 :: RxBuffer1Spec > ; # [doc = "rx buffers"]
pub mod rx_buffer_1 { # [doc = "Register `RX_BUFFER_1[%s]` reader"]
pub type R = crate :: R < RxBuffer1Spec > ; # [doc = "Field `rx_buffer_1` reader - "]
pub type RxBuffer1R = crate :: FieldReader ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn rx_buffer_1 (& self) -> RxBuffer1R { RxBuffer1R :: new (self . bits) } } # [doc = "rx buffers\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_buffer_1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxBuffer1Spec ; impl crate :: RegisterSpec for RxBuffer1Spec { type Ux = u8 ; } # [doc = "`read()` method returns [`rx_buffer_1::R`](R) reader structure"]
impl crate :: Readable for RxBuffer1Spec { } # [doc = "`reset()` method sets RX_BUFFER_1[%s]
to value 0"]
impl crate :: Resettable for RxBuffer1Spec { const RESET_VALUE : u8 = 0 ; } } # [doc = "TX_BUFFER_0 (rw) register accessor: tx buffers\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_buffer_0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tx_buffer_0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tx_buffer_0`]
module"]
# [doc (alias = "TX_BUFFER_0")]
pub type TxBuffer0 = crate :: Reg < tx_buffer_0 :: TxBuffer0Spec > ; # [doc = "tx buffers"]
pub mod tx_buffer_0 { # [doc = "Register `TX_BUFFER_0[%s]` reader"]
pub type R = crate :: R < TxBuffer0Spec > ; # [doc = "Register `TX_BUFFER_0[%s]` writer"]
pub type W = crate :: W < TxBuffer0Spec > ; # [doc = "Field `tx_buffer_0` reader - "]
pub type TxBuffer0R = crate :: FieldReader ; # [doc = "Field `tx_buffer_0` writer - "]
pub type TxBuffer0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn tx_buffer_0 (& self) -> TxBuffer0R { TxBuffer0R :: new (self . bits) } } impl W { # [doc = "Bits 0:7"]
# [inline (always)]
# [must_use]
pub fn tx_buffer_0 (& mut self) -> TxBuffer0W < TxBuffer0Spec > { TxBuffer0W :: new (self , 0) } } # [doc = "tx buffers\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_buffer_0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tx_buffer_0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxBuffer0Spec ; impl crate :: RegisterSpec for TxBuffer0Spec { type Ux = u8 ; } # [doc = "`read()` method returns [`tx_buffer_0::R`](R) reader structure"]
impl crate :: Readable for TxBuffer0Spec { } # [doc = "`write(|w| ..)` method takes [`tx_buffer_0::W`](W) writer structure"]
impl crate :: Writable for TxBuffer0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; } # [doc = "`reset()` method sets TX_BUFFER_0[%s]
to value 0"]
impl crate :: Resettable for TxBuffer0Spec { const RESET_VALUE : u8 = 0 ; } } # [doc = "TX_BUFFER_1 (rw) register accessor: tx buffers\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_buffer_1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tx_buffer_1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tx_buffer_1`]
module"]
# [doc (alias = "TX_BUFFER_1")]
pub type TxBuffer1 = crate :: Reg < tx_buffer_1 :: TxBuffer1Spec > ; # [doc = "tx buffers"]
pub mod tx_buffer_1 { # [doc = "Register `TX_BUFFER_1[%s]` reader"]
pub type R = crate :: R < TxBuffer1Spec > ; # [doc = "Register `TX_BUFFER_1[%s]` writer"]
pub type W = crate :: W < TxBuffer1Spec > ; # [doc = "Field `tx_buffer_1` reader - "]
pub type TxBuffer1R = crate :: FieldReader ; # [doc = "Field `tx_buffer_1` writer - "]
pub type TxBuffer1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn tx_buffer_1 (& self) -> TxBuffer1R { TxBuffer1R :: new (self . bits) } } impl W { # [doc = "Bits 0:7"]
# [inline (always)]
# [must_use]
pub fn tx_buffer_1 (& mut self) -> TxBuffer1W < TxBuffer1Spec > { TxBuffer1W :: new (self , 0) } } # [doc = "tx buffers\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_buffer_1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tx_buffer_1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxBuffer1Spec ; impl crate :: RegisterSpec for TxBuffer1Spec { type Ux = u8 ; } # [doc = "`read()` method returns [`tx_buffer_1::R`](R) reader structure"]
impl crate :: Readable for TxBuffer1Spec { } # [doc = "`write(|w| ..)` method takes [`tx_buffer_1::W`](W) writer structure"]
impl crate :: Writable for TxBuffer1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u8 = 0 ; } # [doc = "`reset()` method sets TX_BUFFER_1[%s]
to value 0"]
impl crate :: Resettable for TxBuffer1Spec { const RESET_VALUE : u8 = 0 ; } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "SPIFLASH_MMAP"]
pub spiflash_mmap : SpiflashMmap , # [doc = "SPIFLASH_PHY"]
pub spiflash_phy : SpiflashPhy , # [doc = "CTRL"]
pub ctrl : Ctrl , # [doc = "ETHMAC"]
pub ethmac : Ethmac , # [doc = "ETHPHY"]
pub ethphy : Ethphy , # [doc = "HUB75_PALETTE"]
pub hub75_palette : Hub75Palette , # [doc = "HUB75"]
pub hub75 : Hub75 , # [doc = "IDENTIFIER_MEM"]
pub identifier_mem : IdentifierMem , # [doc = "SDRAM"]
pub sdram : Sdram , # [doc = "TIMER0"]
pub timer0 : Timer0 , # [doc = "UART"]
pub uart : Uart , # [doc = "ETHMEM"]
pub ethmem : Ethmem , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."]
# [cfg (feature = "critical-section")]
# [inline]
pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Each of the returned peripherals must be used at most once."]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { spiflash_mmap : SpiflashMmap :: steal () , spiflash_phy : SpiflashPhy :: steal () , ctrl : Ctrl :: steal () , ethmac : Ethmac :: steal () , ethphy : Ethphy :: steal () , hub75_palette : Hub75Palette :: steal () , hub75 : Hub75 :: steal () , identifier_mem : IdentifierMem :: steal () , sdram : Sdram :: steal () , timer0 : Timer0 :: steal () , uart : Uart :: steal () , ethmem : Ethmem :: steal () , } } }
